// Test compilation of various expression types

a = -2147483648
b = (a < 0) ? a - 1 : a + 1
return b

/* COMPILE ():
---
    a = -2147483648  // 1:0
    _t0 = lessThan(a, 0)  // 2:0
    branch L2 if not _t0
    b = subtract(a, 1)
    branch L1
  L2:
    b = add(a, 1)
  L1:
    return b  // 3:0
*/

[{ a }] = [{ a: [] }]
return a

/* COMPILE ():
---
    _t0 = unarray1([{a: []}])  // 1:0
    a = unstruct{a}(_t0)
    return a  // 2:0
*/

a = 3
if (a < 2) ? a == 0 : a == 5 {
  return "yes"
}
if a != 2 ?: False {
  return "unlikely"
}
return "no"

/* COMPILE ():
---
    a = 3  // 1:0
    _t0 = lessThan(a, 2)  // 2:0
    branch L2 if not _t0
    _t0 = equal(a, 0)
    branch L1 if not _t0
    branch L3
  L2:
    _t0 = equal(a, 5)
    branch L1 if not _t0
  L3:
    return "yes"  // 3:2
  L1:
    _t0 = equal(a, 2)  // 5:0
    _t0 = not(_t0)
    branch L5 if _t0 is Absent
    branch L4 if not _t0
    branch L6
  L5:
    branch L4
  L6:
    return "unlikely"  // 6:2
  L4:
    return "no"  // 8:0
*/

a = 3
b = a is not Number
return not (b or b is Boolean)

/* COMPILE ():
---
    a = 3  // 1:0
    branch L1 if a is Number  // 2:0
    b = True
    branch L2
  L1:
    b = False
  L2:
    branch L3 if b  // 3:0
    branch L3 if b is Boolean
    _t0 = True
    branch L4
  L3:
    _t0 = False
  L4:
    return _t0
*/

a = Absent
b = False
if a ?: b {
  c = 1
} else {
  c = 2
}
return c

/* COMPILE ():
---
    a = Absent  // 1:0
    b = False  // 2:0
    branch L2 if a is Absent  // 3:0
    branch L1 if not a
    branch L3
    L2:
    branch L1 if not b
    L3:
    c = 1  // 4:2
    branch L4
    L1:
    c = 2  // 6:2
    L4:
    return c  // 8:0
*/

// Multiple updates to a var and/or mixing updates with reads is OK if
// "and", "or", or "?:" determines their ordering

a = 13
b = (nextIsEven(a=) and a != 5) or nextIsEven(a=)
a = nextIsEven(b=) ? nextIsEven(b=) : b
return a

function nextIsEven(a=) {
  a += 1
  return (a % 2) == 0
}

/* COMPILE ():
function nextIsEven(a0=)
method nextIsEven(a) {
    a = binaryUpdate(a, 'add:2', 1)  // 7:2
    _t0 = modulo(a, 2)  // 8:2
    _t0 = equal(_t0, 0)
    return _t0, a
}
---
    a = 13  // 1:0
    _t0, a = nextIsEven(a)  // 2:0
    branch L4 if not _t0
    _t0 = equal(a, 5)
    branch L3 if not _t0
  L4:
    _t0, a = nextIsEven(a)
    branch L1 if not _t0
  L3:
    b = True
    branch L2
  L1:
    b = False
  L2:
    _t0, b = nextIsEven(b)  // 3:0
    branch L6 if not _t0
    a, b = nextIsEven(b)
    branch L5
  L6:
    a = b
  L5:
    return a  // 4:0
*/

a = 5
{"\n": b, a: _} = {"\n": a, a}
return b

/* COMPILE ():
---
    a = 5  // 1:0
    b, _ = unstruct{"\n",a}({"\n": a, a: a})  // 2:0
    return b  // 3:0
*/

a = [{x:C_([4])}]
incr(a[0].x_[0]=)
return a

compound C

procedure incr(a=) {
  a += 1
}

/* COMPILE ():
compound C
procedure incr(a0=)
method incr(a) {
    a = binaryUpdate(a, 'add:2', 1)  // 8:2
    return a  // 8:7
}
---
    a = [{x: C([4])}]  // 1:0
    _t0, _t1 = startUpdate(a, [0])  // 2:0
    _t0, _t2 = startUpdate(_t0, "x")
    _t0, _t3 = _update(_t0)
    _t0, _t4 = startUpdate(_t0, [0])
    _t0 = incr(_t0)
    _t0 = at(_t4, _t0)
    _t0 = at(_t3, _t0)
    _t0 = at(_t2, _t0)
    a = at(_t1, _t0)
    return a  // 3:0
*/

a = [3, 4]
a |= x -> (x > 1 ? x / 2 : x + 1)
return a

/* COMPILE ():
private singleton lambda@2:7 is Lambda
method at(_self, x) _0 is lambda@2:7 {
    _t1 = lessThan(1, x)  // 2:7
    branch L2 if not _t1
    _t0 = divide(x, 2)
    branch L1
  L2:
    _t0 = add(x, 1)
  L1:
    return _t0
}
---
    a = [3, 4]  // 1:0
    a = binaryUpdate(a, 'reversedAt:2', lambda@2:7)  // 2:0
    return a  // 3:0
*/

a = 3
myAssert(a > 2)
return a

procedure myAssert(test) {
  assert test
}

/* COMPILE ():
procedure myAssert(a0)
method myAssert(test) {
    branch L1 if test  // 6:2
    error "Assertion failed"
  L1:
    return   // 6:9
}
---
    a = 3  // 1:0
    _t0 = lessThan(2, a)  // 2:0
    myAssert(_t0)
    return a  // 3:0
*/

// Test statement separation ambiguity

a = 1..
b = 1..
f(2)
return [a, b]

function f(x) = x

/* COMPILE ():
function f(a0)
method f(x) {
    return x  // 6:16
}
---
    a = range(1, None)  // 1:0
    _t0 = f(2)  // 2:0
    b = range(1, _t0)
    return [a, b]  // 4:0
*/
