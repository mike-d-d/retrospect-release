# Compiler tour, Part 3

[TOC]

## An example with control structures

Our next program is a classic insertion sort:

```
procedure insertSort(nums=) {
  for i in 2 .. size(nums) sequential nums {
    // nums[1 .. i-1] are already sorted, insert nums[i] appropriately
    n_i = nums[i]
    dest = i
    for sequential dest {
      if dest == 1 or n_i >= nums[dest - 1] { break }
      dest -= 1
    }
    if dest != i {
      nums[dest+1 .. i] = nums[dest .. i-1]
      nums[dest] = n_i
    }
  }
}
```

Given an array of numbers (or any other values that can be compared with
`lessThan`), this function returns an array with the same elements in ascending
order. Because it is declared with the keyword `procedure`, this function
doesn't have a return value, but its argument is declared as inout (via the
trailing "`=`") so it returns a new value for that argument.

(For a function with a single value to return, like this one, the choice between
returning it as a function value vs. using an inout argument is simply a matter
of style -- there are no performance consequences to choosing one or the other.)

A few reminders about `for` loops in Retrospect:

*   These loops are both marked `sequential` — by default, loops in Retrospect
    are assumed to be parallelizable, but this algorithm requires that they be
    executed sequentially.
*   The `sequential` keyword must be followed by the names of any variables that
    will be updated by the loop body — variables not listed here must be
    read-only, or scoped to a single execution of the body, or *collected* (the
    next part of the tour will look at loops with collected vars).
*   The first loop (beginning "`for i in 2..size(nums)`") will execute its body
    once for each integer in the range, binding "`i`" to the current element
    (unless a `break` statement causes an early exit, but this loop has no
    `break`).
*   The second loop (beginning "`for sequential`") is *unbounded* — it will
    execute its body repeatedly until reaching a `break` statement.

## Calling `iterate` to implement a loop

Surprisingly few instructions are emitted for `insertSort`:

```
procedure insertSort(a0=)

method insertSort(nums) {
    _t0 = size(nums)
    _t0 = range(2, _t0)
    _t0 = iterate(_t0, EnumerateValues, loop@2, loop@2_state(nums))
    nums = unloop@2_state(_t0)
    return nums
}
```

All of the work is happening inside a call to `iterate`, a function that takes
four arguments:

1.  a collection to iterate over (in this case, the range `2..size(nums)` which
    has been computed in `_t0`);
2.  one of three possible singletons identifying the type of iteration (in this
    case `EnumerateValues`, indicating that we want the values from the
    collection but not the corresponding keys);
3.  a loop closure (in this case the singleton `loop@2`); and
4.  an initial state (in this case the compound `loop@2_state(nums)`).

`iterate` calls the `nextState` function once for each element of the
collection, passing the state returned by the previous call in to the next call,
and returns the final state. (As we will see below, it may also return an "early
exit" value, but this loop never exits early.)

After `iterate` returns, the remaining instructions extract the value of `nums`
from the final state and return it (note that the VM doesn't do anything special
with inout arguments; the compiler must insert instructions to return their
final values explicitly).

This code is generated by `PassThree.visitForStatement`, which is dauntingly
complex to handle all the possible complexities of `for` statements:

*   sequential or parallel execution
*   collected variables and sequential variables
*   `break` statements

In this case we have sequential execution, no collected variables, and no
`break` statements, so most of that complexity is skipped and it boils down to

```
// Get Exprs for the source collection ("2..size(nums)") and the initial state
int tmpState = blockCompiler.saveTmpState();
Expr source = blockCompiler.compile(forLoop.expression());
Expr initialState = loop.stateCompound.make(loop.stateVars.get(0).outer.local);
blockCompiler.resetTmps(tmpState);
// Allocate a temporary to hold the result returned by iterate()
Local finalState = blockCompiler.newTmp();
// With no closed-over variables, this is just a singleton
Expr loopClosure = loop.scope.getClosure(new Local[0]);
// Emit the call to iterate()
instructionBlock.emitCall(
    finalState,
    vmCore().lookupFunction("iterate", 4),
    source,
    vmCore().lookupSingleton("EnumerateValues"),
    loopClosure,
    initialState);
// Emit the call to extract the state components (in this case to "nums")
instructionBlock.emitCall(
    loop.stateVars.get(0).outer.local,
    loop.stateCompound.extract(),
    finalState);
```

Also note that `PassTwo.visitForStatement` calls `Loop.donePassTwo` once it has
determined which variables need to be closed over (none in this case — `loop@2`
is a singleton), which in turn creates a subtask to compile the loop body; we'll
look at the results of that next.

## The outer loop body

In addition to the `iterate` call, the compiler must define the type for the
loop closure and the loop state, and must define a `nextState` method for the
closure type (just as we had to define an `at` method for the Lambda type in the
previous section):

```
private singleton loop@2 is Loop
private compound loop@2_state{nums}

method nextState(_loop, _state, _element) _0 is loop@2 {
    nums = unloop@2_state(_state)
    i = _element
    n_i = getOp(nums, [i])
    dest = i
    _t0 = iterateUnbounded(loop@6(n_i, nums), loop@6_state(dest))
    _t0 = loopExitState(_t0)
    dest = unloop@6_break(_t0)
    _t0 = equal(dest, i)
    branch L3 if _t0
    _t0 = subtract(i, 1)
    _t0 = range(dest, _t0)
    _t0 = getOp(nums, [_t0])
    _t1 = add(dest, 1)
    _t1 = range(_t1, i)
    nums = replaceElement(nums, [_t1], _t0)
    nums = replaceElement(nums, [dest], n_i)
  L3:
    return loop@2_state(nums)
}
```

`nextState` is called with three arguments:

1.  the loop closure (this method is declared to be applicable only when the
    first argument is the singleton `loop@2`);
2.  the state returned by the previous iteration (or the initial state passed to
    `iterate`, if this is the first element of the collection); and
3.  an element of the collection (in this case, an integer between 2 and
    `size(nums)`).

Our `nextState` method starts by extracting `nums` from the state (which will
always be an instance of our `loop@2_state` compound) and initializing `i` from
the `_element` argument. It compiles `n_i = nums[i]` as a call to the `getOp`
function.

The inner loop is compiled as a call to `iterateUnbounded`, a function similar
to `iterate` but with no collection. Like `iterate` it takes a loop closure and
an initial state, and returns a final state, but it will only return when it
reaches an early exit state (since there is no collection to exhaust). This time
the loop (`loop@6(n_i, nums)`) is closed over two variables, and the loop state
consists of the `dest` value.

After the `iterateUnbounded` returns we extract the final state from the "this
is an early exit" marker (that's the `loopExitState` function), and then extract
`dest` from the final state. This uses some more of the features in
`PassThree.visitForStatement` — in particular, the logic to extract the final
state from an early exit (if there was a block associated with the break this is
where it would be emitted).

(Note that the final state has a different type than the initial state; in
general `break` statements may return only some of the loop's state, and may
include additional information, but in this case both loop state and exit state
contain only the value of `dest`.)

Once the final value of `dest` has been determined by the inner loop, the `if
dest != i` statement is compiled to a call to the `equals` function (which
returns `True` or `False`), and a conditional branch instruction (which MockVM
represents as `branch L3 if _t0`). The only thing unusual about branches in the
Retrospect VM is that they must go forward — backward branches (conditional or
unconditional) are not allowed.

(If we had backward branches, we could have compiled these loops with
conditional branches instead of calls to `iterate` and `iterateUnbounded`. But
we need to implement loop closures and state values to support parallel loops,
and it's simpler for the compiler to use the same structure to support
sequential loops; only supporting forward branches also makes the VM a little
simpler.)

The assignments "`nums[dest+1..i] = nums[dest..i-1]`" and "`nums[dest] = n_i`"
are compiled as calls to the `replaceElement` function, which takes a
collection, a key, and a value, and returns the updated collection.

The final instruction (reached either by the conditional branch to `L3` or after
executing the `replaceElement` calls) just returns the updated state, consisting
of the updated value of `nums`.

This complete sequence of instructions was emitted by `Loop.compileBody`, which
has complexity to handle parallelism, collected variables, and keyed iteration,
but in this case boils down to

```
// Does nothing, since there are no closed-over variables
scope.emitInitFromSelf(selfArg);
// We have a single stateVar ("nums"); extract it from the state argument...
Local[] sVars = new Local[]{ stateVars.get(0).inner.local };
instructionBlock.emitCall(sVars, stateCompound.extract(), stateArg);
// ... and create the compound Expr we will use as our return value.
Expr returnValue = stateCompound.make(sVars);
// The label we would branch to from a "continue" statement, if we encountered one
continueTarget = ib.newTarget();
// This emits "i = _element"
extract(forLoop.value, elementArg);
// Compile the statements in the loop, using the Loop scope
PassThree.apply(this, forLoop.block());
// ... and we're done.
instructionBlock.defineTarget(continueTarget);
instructionBlock.emitReturn(returnValue);
```

## The inner loop body

As with the outer loop, the compiler define types for the loop closure and loop
state; it also defines a type for the result returned by the `break` statement,
although (as noted above) for this loop the break state ends up having the same
shape as the non-break state:

```
private compound loop@6{n_i,nums} is Lambda
private compound loop@6_break{dest}
private compound loop@6_state{dest}
```

`iterateUnbounded()` doesn't call `nextState`, since it doesn't have an element
to pass; instead it calls the same `at` function that was used for Lambda
values, so the compiler defines a method for that:

```
method at(_loop, _state) _0 is loop@6 {
    n_i, nums = unloop@6(_loop)
    dest = unloop@6_state(_state)
    _t0 = equal(dest, 1)
    branch L3 if _t0
    _t0 = subtract(dest, 1)
    _t0 = getOp(nums, [_t0])
    _t0 = lessThan(n_i, _t0)
    branch L2 if _t0
  L3:
    _t0 = loopExit(loop@6_break(dest))
    return _t0
  L2:
    dest = binaryUpdate(dest, 'subtract:2', 1)
    return loop@6_state(dest)
}
```

Comparing that with the Retrospect code:

```
for sequential dest {
  if dest == 1 or n_i >= nums[dest - 1] { break }
  dest -= 1
}
```

... the correspondence is pretty clear. The first two instructions extract our
closed-over and state variables. The `if` condition is compiled to two
conditional branches, the first using `equal` and the second using `lessThan`
(all of `<`, `<=`, `>`, and `>=` compile to the same `lessThan` function).

If the `if` condition is true, the `at` method returns an early exit value
(constructed by calling the `loopExit` function); otherwise it returns the
updated state.

The interestingly new parts of this code generation are the `break` statement
(emitted by `Loop.Break.passThree`) and the `if` statement (emitted by
`PassThree.visitIfStatement`). Compiling the `if` uses a `Tester` (the second
subclass of ExpressionCompiler, mentioned earlier), which overrides
`visitConjExpression` to handle `and` and `or` without having to store the
result in a Local.

--------------------------------------------------------------------------------

[Part 1](compiler_tour_1.md) &nbsp; &nbsp; [Part 2](compiler_tour_2.md) &nbsp;
&nbsp; <> &nbsp; &nbsp; [Part 4](compiler_tour_4.md)
