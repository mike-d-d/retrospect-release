// Based on https://code.earthengine.google.com/705ba57988f51d1ff90ebbc7bf33c83c

scale = size * size / 100
b0 = testBand(size * 0.3, size * 0.3, scale)
b1 = testBand(size * 0.3, size * 0.7, scale)
b2 = testBand(size * 0.7 , size * 0.5, scale)
b3 = [x, y] -> floor(x) + floor(y) * size
img = { b0, b1, b2, b3 }

// Create a (lazily-computed) matrix of features
features = matrix([size, size])
             | [i, j] -> feature([i - 0.5, j - 0.5], img)

centroids =
    [[0, 0, 0], [0.6, 0, 0], [0, 0.6, 0], [0, 0, 0.6], [0.55, 0.55, 0.55],
     [0.2, 0.2, 0], [0.2, 0, 0.2], [0, 0.2, 0.2],
     [0.1, 0.1, 0.3], [0.3, 0.1, 0.1], [0.1, 0.3, 0.1]]

// Classify each feature and save a list of the filtered results
filtered = features
     | f -> classify(f, centroids, keep)
     | filter(f -> f.filter == 0)
     | saveSequential

// Return the length of the list and its last element
return { count: size(filtered), last: filtered[size(filtered)] }

function testBand(xc, yc, scale) =
    [x, y] -> testBandHelper([x, y] - [xc, yc], scale)

function testBandHelper(delta, scale) {
  d = delta ** 2
  d2 = d[2] + d[1]
  return 1 / (log(d2 / scale + 7 - 6) + 1)
}

// Evaluate each of the bands at the given xy coordinates and save the results
// as a struct.
function feature(xy, bands) = bands | b -> b @ xy | save

// Translation of the "classify()" function in the code editor script, which
// given a feature with properties b0, b1, and b2, adds
// - a "distance<i>" property with the squared distance to each centroid
// - a "class" property with the index of the closest centroid
// - a "filter" property that will be 0 for 1 in <keep> of the features
function classify(f, centroids, keep) {
  b0 = f.b0
  b1 = f.b1
  b2 = f.b2
  b3 = f.b3
  pt = [b0, b1, b2]
  // Spammy because we're approximating the results of translating the EE
  // expression, where the loop is on the client side.
  distance0 = dist(pt, centroids[1])
  distance1 = dist(pt, centroids[2])
  distance2 = dist(pt, centroids[3])
  distance3 = dist(pt, centroids[4])
  distance4 = dist(pt, centroids[5])
  distance5 = dist(pt, centroids[6])
  distance6 = dist(pt, centroids[7])
  distance7 = dist(pt, centroids[8])
  distance8 = dist(pt, centroids[9])
  distance9 = dist(pt, centroids[10])
  distance10 = dist(pt, centroids[11])
  distances = [[distance0, 0],
               [distance1, 1],
               [distance2, 2],
               [distance3, 3],
               [distance4, 4],
               [distance5, 5],
               [distance6, 6],
               [distance7, 7],
               [distance8, 8],
               [distance9, 9],
               [distance10, 10]]
  min = distances | minAt([1])

  // We don't yet have a way to build the struct incrementally, so we
  // assemble it in a single step.
  return { b0, b1, b2, b3,
           distance0, distance1, distance2, distance3, distance4, distance5,
           distance6, distance7, distance8, distance9, distance10,
           class: min[2],
           filter: b3 % keep }
}

function dist(pt, centroid) = (centroid - pt) ** 2 | sum

/* RUN (size=200, keep=800) RETURNS
{count: 50,
 last:
    {b0: 0.19868774362729588, b1: 0.2576687013636895, b2: 0.1890531704608046,
     b3: 39200, class: 10,
     distance0: 0.14161108039143833, distance1: 0.2631857880386832,
     distance10: 0.0194616767556045, distance2: 0.19240863875501088,
     distance3: 0.2747472758384728, distance4: 0.33916050339446935,
     distance5: 0.03906850239504415, distance6: 0.06651471475619812,
     distance7: 0.04292233166164067, distance8: 0.046907889116758465,
     distance9: 0.04305405985016195,
     filter: 0}}
---
allocated=3084808264/117146698, peak=12384
$0 = *[]Struct(["b0", "b1", "b2", "b3", "class", "distance0", "distance1", "distance10", "distance2", "distance3", "distance4", "distance5", "distance6", "distance7", "distance8", "distance9", "filter"], x0:$1)
$1 = *[]d0
*/
