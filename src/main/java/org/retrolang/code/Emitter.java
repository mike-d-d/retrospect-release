/*
 * Copyright 2025 The Retrospect Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.retrolang.code;

import org.retrolang.code.CodeBuilder.OpCodeType;
import org.retrolang.util.Bits;
import org.retrolang.util.SmallIntMap;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.util.Arrays;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

/**
 * An Emitter is used by {@link CodeBuilder#load} to manage the details of emitting JVM bytecode for
 * a single Java method.
 *
 * <p>The Emitter is only created after the block graph is finalized, so it can use the {@link
 * Block#index} value to index structures like {@link #labels}, {@link #exceptionHandlers}, and
 * {@link #needsFrame} without worrying about it changing.
 */
public class Emitter {
  /** The CodeBuilder that is emitting this code. */
  public final CodeBuilder cb;

  /** The return type of the Java method. */
  final Class<?> returnType;

  /** The size of the local variable array required for the generated bytecode. */
  private final int numLocals;

  /** The {@link Loader} that will be used to turn the emitted bytecode into a MethodHandle. */
  private final Loader loader = Loader.newLoader();

  /** The interface for writing bytecode. */
  public MethodVisitor mv;

  /** The stack depth after the most recently emitted instruction. */
  private int currentStackDepth;

  /** The maximum value of {@link #currentStackDepth}. */
  private int maxStackDepth;

  /** One Label corresponding to each block, indexed by block.index(). */
  private Label[] labels;

  /** An ExceptionHandler for each block that is the target of a SetBlock.WithCatch. */
  private final SmallIntMap.Builder<ExceptionHandler> exceptionHandlers =
      new SmallIntMap.Builder<>();

  /**
   * True if we must emit a stack map frame before the corresponding block (because it is the target
   * of a jump instruction or the start of an exception handler).
   */
  private final Bits.Builder needsFrame = new Bits.Builder();

  /** A Sequencer that will determine the order in which blocks are emitted. */
  private final Sequencer sequencer;

  Emitter(CodeBuilder cb, Class<?> returnType, int numLocals, Sequencer sequencer) {
    this.cb = cb;
    this.returnType = returnType;
    this.numLocals = numLocals;
    this.sequencer = sequencer;
  }

  /** Returns the stack depth after the most recently emitted instruction. */
  public int currentStackDepth() {
    return currentStackDepth;
  }

  /** Must be called when emitting instructions that change the stack depth. */
  public void setStackDepth(int n) {
    assert n >= 0;
    currentStackDepth = n;
    maxStackDepth = Math.max(maxStackDepth, n);
  }

  /**
   * Increments the current stack depth; often more convenient than calling {@link #setStackDepth}.
   */
  public void addToStackDepth(int n) {
    setStackDepth(currentStackDepth + n);
  }

  /** Emits an instruction to push the given int constant on the stack. */
  public void pushI(int i) {
    addToStackDepth(1);
    // In addition to the most generic instruction (LDC), the JVM has 9 (!) more compact
    // instructions for common special cases.  I don't know how much (if any) benefit we
    // get from using them.
    switch (i) {
      case -1:
        mv.visitInsn(Opcodes.ICONST_M1);
        return;
      case 0:
        mv.visitInsn(Opcodes.ICONST_0);
        return;
      case 1:
        mv.visitInsn(Opcodes.ICONST_1);
        return;
      case 2:
        mv.visitInsn(Opcodes.ICONST_2);
        return;
      case 3:
        mv.visitInsn(Opcodes.ICONST_3);
        return;
      case 4:
        mv.visitInsn(Opcodes.ICONST_4);
        return;
      case 5:
        mv.visitInsn(Opcodes.ICONST_5);
        return;
      default:
        break;
    }
    if (i == (byte) i) {
      mv.visitIntInsn(Opcodes.BIPUSH, i);
    } else if (i == (short) i) {
      mv.visitIntInsn(Opcodes.SIPUSH, i);
    } else {
      mv.visitLdcInsn(i);
    }
  }

  /**
   * Prepares for a conditional branch comparing the top of stack with a constant integer. The
   * caller should assume that the operands have been pushed and just emit the branch that is
   * returned.
   *
   * <p>In the general case this just pushes the given int and returns the branch unchanged, but if
   * {@code rhs} is zero (or the branch can be tweaked to be a comparison with zero) we can skip the
   * push and use a "compare with zero" opcode, e.g. instead of "ICONST_0, IF_ICMPGE" we can just
   * emit "IFGE".
   */
  public ConditionalBranch pushForCompare(ConditionalBranch branch, int rhs) {
    assert branch.isIcmp();
    if (rhs == 0) {
      return branch.withZero();
    } else if (rhs == 1) {
      if (branch == ConditionalBranch.IF_ICMPGE) {
        // >= 1 is > 0
        return ConditionalBranch.IFGT;
      } else if (branch == ConditionalBranch.IF_ICMPLT) {
        // < 1 is <= 0
        return ConditionalBranch.IFLE;
      }
    } else if (rhs == -1) {
      if (branch == ConditionalBranch.IF_ICMPGT) {
        // > -1 is >= 0
        return ConditionalBranch.IFGE;
      } else if (branch == ConditionalBranch.IF_ICMPLE) {
        // <= -1 is < 0
        return ConditionalBranch.IFLT;
      }
    }
    pushI(rhs);
    return branch;
  }

  /**
   * Prepares for a conditional branch comparing two integers. Will either test {@code branch} with
   * {@code (lhs, rhs)}, or will test {@code swapped} with {@code (rhs, lhs)}. The caller should
   * assume that the operands have been pushed and just emit the branch that is returned.
   */
  public ConditionalBranch intCompare(
      CodeValue lhs, CodeValue rhs, ConditionalBranch branch, ConditionalBranch swapped) {
    assert branch.isIcmp() && swapped.isIcmp();
    if (rhs instanceof CodeValue.Const) {
      lhs.push(this, int.class);
      return pushForCompare(branch, rhs.iValue());
    } else if (lhs instanceof CodeValue.Const) {
      rhs.push(this, int.class);
      return pushForCompare(swapped, lhs.iValue());
    } else {
      lhs.push(this, int.class);
      rhs.push(this, int.class);
      return branch;
    }
  }

  /** Emits an instruction to push the given double constant on the stack. */
  public void pushD(double d) {
    addToStackDepth(2);
    // There are a couple of special cases here, but many fewer than with ints.
    if (d == 0) {
      mv.visitInsn(Opcodes.DCONST_0);
    } else if (d == 1) {
      mv.visitInsn(Opcodes.DCONST_1);
    } else {
      // If d is actually an int it would also be possible to call pushI() followed by I2D;
      // although that might be slightly more compact I don't know that it's cheaper in any way.
      mv.visitLdcInsn(d);
    }
  }

  /** Emits an instruction to push the given double constant on the stack. */
  public void pushF(float f) {
    addToStackDepth(1);
    // There are a couple of special cases here, but many fewer than with ints.
    if (f == 0) {
      mv.visitInsn(Opcodes.FCONST_0);
    } else if (f == 1) {
      mv.visitInsn(Opcodes.FCONST_1);
    } else if (f == 2) {
      mv.visitInsn(Opcodes.FCONST_2);
    } else {
      // If f is actually an int it would also be possible to call pushI() followed by I2F;
      // although that might be slightly more compact I don't know that it's cheaper in any way.
      mv.visitLdcInsn(f);
    }
  }

  /** Emits an instruction to push the given long constant on the stack. */
  public void pushL(long j) {
    addToStackDepth(2);
    if (j == 0) {
      mv.visitInsn(Opcodes.LCONST_0);
    } else if (j == 1) {
      mv.visitInsn(Opcodes.LCONST_1);
    } else {
      // In practice we mostly use this for offsets passed to Unsafe, and most of those are small
      // so I *think* this is worthwhile.
      int i = (int) j;
      if (i == j) {
        pushI(i);
        mv.visitInsn(Opcodes.I2L);
      } else {
        mv.visitLdcInsn(j);
      }
    }
  }

  /**
   * Emits an instruction to push the given Object constant on the stack. The Java verifier will
   * assume that it's an object of the given type.
   */
  public void pushX(Object x, Class<?> type) {
    assert type == null || !type.isPrimitive();
    addToStackDepth(1);
    if (x == null) {
      mv.visitInsn(Opcodes.ACONST_NULL);
      return;
    }
    if (x instanceof String) {
      // For now we just put strings in the constant pool, but that may not preserve identity;
      // if that mattered we could use emitLoadConstant for them as well.
      mv.visitLdcInsn(x);
    } else {
      // The exact instruction emitted depends on which code-loading API we're using.
      loader.emitLoadConstant(x, type);
    }
  }

  /** Emits an instruction to cast the object on the top of the stack to the given type. */
  public void cast(Class<?> type) {
    mv.visitTypeInsn(Opcodes.CHECKCAST, org.objectweb.asm.Type.getInternalName(type));
  }

  /**
   * If necessary, emits an instruction to coerce the top of stack (which is currently of type
   * {@code fromType}) to {@code toType}.
   *
   * <p>Cannot coerce from primitive to non-primitive or vice-versa. If both types are primitive,
   * must generally be a widening conversion (e.g. from int to double, but not vice-versa), except
   * that ints, bytes, and booleans are all considered equivalent (since the JVM doesn't distinguish
   * among them on the stack).
   */
  public void coerce(Class<?> fromType, Class<?> toType) {
    if (!toType.isAssignableFrom(fromType)) {
      if (toType == double.class) {
        if (fromType == long.class) {
          mv.visitInsn(Opcodes.L2D);
        } else if (fromType == float.class) {
          mv.visitInsn(Opcodes.F2D);
        } else {
          assert OpCodeType.isStoredAsInt(fromType);
          mv.visitInsn(Opcodes.I2D);
        }
      } else if (toType == float.class) {
        if (fromType == long.class) {
          mv.visitInsn(Opcodes.L2F);
        } else if (fromType == double.class) {
          mv.visitInsn(Opcodes.D2F);
        } else {
          assert OpCodeType.isStoredAsInt(fromType);
          mv.visitInsn(Opcodes.I2F);
        }
      } else if (toType == long.class) {
        assert OpCodeType.isStoredAsInt(fromType);
        mv.visitInsn(Opcodes.I2L);
      } else if (OpCodeType.isStoredAsInt(toType)) {
        assert OpCodeType.isStoredAsInt(fromType);
      } else {
        assert !(fromType.isPrimitive() || toType.isPrimitive());
        cast(toType);
      }
    }
  }

  /**
   * Emits instructions to push a register's value on the stack, coercing it to the given type if
   * necessary.
   */
  void push(Register register, Class<?> type) {
    OpCodeType opCodeType = register.opCodeType();
    int initStackDepth = currentStackDepth;
    mv.visitVarInsn(opCodeType.loadVarOpcode, register.jvmLocal());
    coerce(register.type(), type);
    setStackDepth(initStackDepth + OpCodeType.localSize(type));
    // Coercing a long to a float reduces its stack size, so it's possible that our max depth
    // was greater than our current depth.
    maxStackDepth = Math.max(maxStackDepth, initStackDepth + opCodeType.size);
  }

  /** Emits an instruction to pop the stack and store the value in the given register. */
  public void store(Register register) {
    mv.visitVarInsn(register.opCodeType().storeVarOpcode, register.jvmLocal());
  }

  /**
   * Emits a call to {@link MethodHandle#invokeExact} with the appropriate types for the given
   * MethodHandle.
   */
  public void emitInvokeExact(MethodHandle mh) {
    mv.visitMethodInsn(
        Opcodes.INVOKEVIRTUAL,
        org.objectweb.asm.Type.getInternalName(MethodHandle.class),
        "invokeExact",
        mh.type().toMethodDescriptorString(),
        false);
  }

  /**
   * Emits instructions that branch to ifTrue if the ConditionalBranch is true and ifFalse
   * otherwise, assuming that the emitted code falls through to the returned Block.
   */
  public Block conditionalBranch(ConditionalBranch branch, Link ifTrue, Link ifFalse) {
    if (sequencer.isLinkToNextBlock(ifFalse)) {
      mv.visitJumpInsn(branch.opcode, jumpTo(ifTrue.targetBlock()));
      return ifFalse.targetBlock();
    } else {
      mv.visitJumpInsn(branch.invert().opcode, jumpTo(ifFalse.targetBlock()));
      return ifTrue.targetBlock();
    }
  }

  /**
   * Called when emitting a jump to the given block; in addition to returning the appropriate Label
   * will ensure that a frame is emitted at that label.
   */
  public Label jumpTo(Block block) {
    // Any block that's jumped to must be preceded by a stack map frame.
    needsFrame.set(block.index());
    return labels[block.index()];
  }

  /** Returns true if the given link is implemented by catching an exception. */
  private static boolean isException(Link link) {
    return link.origin instanceof SetBlock.WithCatch withCatch && link == withCatch.alternate;
  }

  /**
   * Returns the Label of the exception-handling stub that will resume execution with the given
   * block.
   */
  public Label exceptionHandler(Block block) {
    return exceptionHandlers.get(block.index()).label;
  }

  /**
   * Called once on each Emitter to drive the code-generation process. Calls {@link Block#emit} on
   * each block in the graph (in the order assigned by the Sequencer), adding branches and stack map
   * frames as needed. Loads the resulting bytecode as a new MethodHandle and returns it.
   */
  MethodHandle emit(String methodName, String sourceFileName, MethodHandles.Lookup lookup) {
    loader.initialize(methodName, cb.methodType(returnType), lookup, sourceFileName);
    mv = loader.methodVisitor();

    // The bytecode for each block will be preceded with a label (even if we don't branch to them,
    // we need the label to attach the line number).
    // (There is no bytecode emitted for the InitialBlock, so no label is needed for it -- that's
    // why the loop starts at 1.)
    labels = new Label[cb.numBlocks()];
    for (int i = 1; i < labels.length; i++) {
      labels[i] = new Label();
      Block b = cb.block(i);
      // Also, every block that is the alternate target of a SetBlock.WithCatch needs an extra
      // ExceptionHandler label (to drop the exception from the stack)
      if (b instanceof SetBlock.WithCatch withCatch) {
        Block target = withCatch.alternate.targetBlock();
        if (!exceptionHandlers.containsKey(target.index())) {
          ExceptionHandler handler = new ExceptionHandler(target);
          exceptionHandlers.put(target.index(), handler);
        }
      }
    }
    // FrameEmitter handles the complexity of generating stack frame maps.
    FrameEmitter frameEmitter = new FrameEmitter();
    // emit blocks in the order assigned by the Sequencer
    assert sequencer.orderedBlock(0) == cb.initialBlock();
    // On each loop iteration, fallThroughTo will be the block that the previous block expected to
    // fall through to, or null if it did not have a fall through path.
    Block fallThroughTo = cb.initialBlock().next.targetBlock();
    for (int i = 1; i < cb.numBlocks(); i++) {
      Block b = sequencer.orderedBlock(i);
      if (fallThroughTo != null && fallThroughTo != b) {
        // If the previous block fell through to someone else, insert a branch.
        mv.visitJumpInsn(Opcodes.GOTO, jumpTo(fallThroughTo));
      }
      // Will the JVM require a stack map frame for this block?  Yes if we've already emitted a
      // branch to it, or if it has an inlink from a non-yet-emitted block.
      // (But exception-handler links don't count because they'll go to the stub, which gets its
      // own stack map frame.)
      int finalI = i;
      boolean emitFrame =
          needsFrame.test(b.index())
              || b.anyInlink(
                  link -> sequencer.position(link.origin) >= finalI && !isException(link));
      // Is this block the exception handler for any SetBlock.WithCatch blocks?
      ExceptionHandler handler = exceptionHandlers.get(b.index());
      if (handler != null) {
        if (fallThroughTo != b) {
          // If we didn't fall through to this block we can just emit the stub in front of it
          handler.emit(this, frameEmitter);
        } else {
          // Otherwise we'll emit the stub after all the blocks, and it will branch back to here,
          // so we need a frame.
          emitFrame = true;
        }
      }
      Label label = labels[b.index()];
      mv.visitLabel(label);
      // Setting the line number to the block index makes stack traces more useful
      mv.visitLineNumber(i, label);
      if (emitFrame) {
        frameEmitter.emitFrame(b, false);
      }
      // All blocks start with stack depth 0.
      currentStackDepth = 0;
      fallThroughTo = b.emit(this);
    }
    if (fallThroughTo != null) {
      mv.visitJumpInsn(Opcodes.GOTO, jumpTo(fallThroughTo));
    }
    // Any exception handler stubs that didn't get emitted above will be emitted here
    exceptionHandlers.forEachEntry(
        (index, handler) -> {
          if (!handler.emitted) {
            handler.emit(this, frameEmitter);
            mv.visitJumpInsn(Opcodes.GOTO, labels[index]);
          }
        });
    mv.visitMaxs(maxStackDepth, numLocals);
    return loader.load(cb.debugInfo);
  }

  /**
   * We create an ExceptionHandler for each block that is the alternate (exception handling) target
   * of a SetBlock.WithCatch.
   */
  private static class ExceptionHandler {
    /**
     * The Label for the exception handler stub, which is just a POP instruction to discard the
     * exception from the stack followed by {@link #block}.
     */
    final Label label = new Label();

    /** The block at which execution should resume after an exception. */
    final Block block;

    /** True if {@link #label} has been emitted. */
    boolean emitted;

    ExceptionHandler(Block block) {
      this.block = block;
    }

    /** Must be called exactly once for each ExceptionHandler. */
    void emit(Emitter emitter, FrameEmitter frameEmitter) {
      assert !emitted;
      emitter.mv.visitLabel(label);
      frameEmitter.emitFrame(block, true);
      emitter.mv.visitInsn(Opcodes.POP);
      emitted = true;
    }
  }

  /**
   * The JVM verifier (run on each method's bytecode at load time) requires that each instruction
   * that can be branched to be annotated with a "stack map frame" that lists the type of each live
   * local variable and each stack entry.
   *
   * <p>More precisely: a stack map frame is two arrays of type identifiers, one for local variables
   * and one for the stack. Each entry in the array is an Integer (identifying a primitive type) or
   * a String (the name of any non-primitive type).
   *
   * <p>ASM is able to insert these automatically (see ClassWriter.COMPUTE_FRAMES), but to do so it
   * must run a potentially complex control-flow analysis on the bytecode; since we already have all
   * the necessary information at hand we prefer to skip that cost and generate them ourselves.
   *
   * <p>Aside from somewhat funky type conventions, the trickiest part of this is that the JVM uses
   * a bespoke compression scheme to minimize the size of the annotations: each stack map frame can
   * be encoded in one on five different ways, all but one of which are relative to the preceding
   * frame annotation. ("Preceding" here means in the order instructions are emitted, not the order
   * they are executed. All methods begin with an implicit frame annotation containing just the
   * method arguments and an empty stack, so the first explicit frame annotation can be relative to
   * that).
   *
   * <p>The possible encodings of a frame are
   *
   * <ul>
   *   <li>FULL: The contents of both arrays are provided. This is the most general option, and the
   *       only one that does not depend on the preceding frame annotation.
   *   <li>SAME: No arrays are provided. The local variables are the same as the previous frame, and
   *       the stack is empty.
   *   <li>SAME1: A single-entry stack map is provided. The local variables are the same as the
   *       previous frame.
   *   <li>CHOP: Only the length of the new local variables array is provided, which must be between
   *       one and three elements less than the preceding frame. A prefix of the previous local
   *       variable array is used, and the stack is empty.
   *   <li>APPEND: Between one and three new elements are provided to append to the previous local
   *       variable array. The stack is empty.
   * </ul>
   */
  private class FrameEmitter {
    /** The local variable array as of the last frame we emitted. */
    private Object[] prevTypes;

    /** The number of valid entries in {@link #prevTypes}. */
    private int numPrevTypes;

    /** Used temporarily during a single call to {@link #emitFrame}. */
    private final Object[] localTypesScratch;

    FrameEmitter() {
      localTypesScratch = new Object[numLocals];
      numPrevTypes = cb.numArgs();
      prevTypes = new Object[numPrevTypes];
      Arrays.setAll(prevTypes, i -> frameType(cb.register(i).type()));
    }

    void emitFrame(Block block, boolean forExceptionHandler) {
      // All blocks have an initially-empty stack; the only frames with non-empty stacks are those
      // for exception handler stubs, which have a single exception on the stack.
      Object[] stackTypes = forExceptionHandler ? exceptionHandlerStack : null;
      int stackSize = forExceptionHandler ? 1 : 0;
      int numTypes = getLocalTypes(block, localTypesScratch);
      int numCommon = Arrays.mismatch(prevTypes, 0, numPrevTypes, localTypesScratch, 0, numTypes);
      // Currently stackSize is always <= 1 so that check is redundant, but some day we might want
      // to generate frames with deeper stacks.
      if (numCommon < 0 && stackSize <= 1) {
        // Locals are identical
        int opCode = (stackSize == 0) ? Opcodes.F_SAME : Opcodes.F_SAME1;
        mv.visitFrame(opCode, 0, null, stackSize, stackTypes);
      } else if (numCommon == numTypes && numCommon >= numPrevTypes - 3 && stackSize == 0) {
        // Locals are a prefix of the previous types
        mv.visitFrame(Opcodes.F_CHOP, numPrevTypes - numTypes, null, stackSize, stackTypes);
      } else {
        // Make a copy of localTypesScratch, since we'll change it next time through
        prevTypes = Arrays.copyOf(localTypesScratch, numTypes);
        if (numCommon == numPrevTypes && numCommon >= numTypes - 3 && stackSize == 0) {
          // Locals are an extension of the previous types
          mv.visitFrame(
              Opcodes.F_APPEND,
              numTypes - numPrevTypes,
              Arrays.copyOfRange(localTypesScratch, numPrevTypes, numTypes),
              stackSize,
              stackTypes);
        } else {
          // MethodWriter doesn't save a pointer to the Object[]s we pass, so we're skipping the
          // defensive copy.
          mv.visitFrame(Opcodes.F_FULL, numTypes, prevTypes, stackSize, stackTypes);
        }
      }
      numPrevTypes = numTypes;
    }
  }

  /**
   * The stack map on entry to an exception handling stub: contains one element of type Throwable.
   */
  private static final Object[] exceptionHandlerStack =
      new Object[] {Type.getInternalName(Throwable.class)};

  /** The object used in stack map frames to identify values of the given type. */
  private static Object frameType(Class<?> type) {
    // Primitive types get special codes, everything else uses the "internal type name".
    OpCodeType opCodeType = OpCodeType.forType(type);
    return (opCodeType == OpCodeType.OBJ) ? Type.getInternalName(type) : opCodeType.frameType;
  }

  /**
   * Sets {@code output} to describe the types of the Java locals before executing Block, and
   * returns its length (i.e. the number of entries before all the remaining ones are TOP).
   */
  private int getLocalTypes(Block block, Object[] output) {
    int length = 0;
    // Longs and Doubles occupy two slots in the locals array but only one in the frame map...
    // To deal with that madness we initially assign them two slots in the frame map, put null
    // in the second slot, and then remove the nulls when we're done.
    int numNulls = 0;
    // TOP means "not in use"
    Arrays.fill(output, Opcodes.TOP);
    // The Java locals currently in use are those that correspond to live registers
    for (int registerIndex : block.live()) {
      Register r = cb.register(registerIndex);
      int localNum = r.jvmLocal();
      Class<?> type = r.type();
      Object prev = output[localNum];
      if (prev == Opcodes.TOP) {
        output[localNum] = frameType(type);
        if (OpCodeType.localSize(type) == 2) {
          localNum++;
          assert output[localNum] == Opcodes.TOP;
          output[localNum] = null;
          ++numNulls;
        }
        length = Math.max(length, localNum + 1);
      } else {
        // It's possible that multiple live registers are assigned the same Java local, but if so
        // they should all be aliases with the same type.
        assert frameType(type).equals(prev)
            && (OpCodeType.localSize(type) == 1 || output[localNum + 1] == null);
      }
    }
    if (numNulls != 0) {
      // Remove the nulls and compact
      int end = 0;
      for (int i = 0; i < length; i++) {
        if (output[i] != null) {
          output[end++] = output[i];
        }
      }
      assert end + numNulls == length;
      length = end;
    }
    return length;
  }
}
