// Test execution of expressions with distributed operators and functions

a = 1..3
left = a ^/ 4 | save
right = 4 +^ a | save
both = a ^*^ a | save

return { both, left, right }

/* RUN () RETURNS
  {both: [1, 4, 9],
   left: [0.25, 0.5, 0.75],
   right: [5, 6, 7]}
---
allocated=8472/318, peak=344
*/

a = 0..2
lt = a ^< 2 | save
le = a ^<= 2 | save
le2 = 2 <=^ a | save
ne = a ^!=^ (-^a) | save

return [lt, le, le2, ne]

/* RUN () RETURNS
  [[True, True, False],
   [True, True, True],
   [False, False, True],
   [False, True, True]]
---
allocated=13160/496, peak=280
*/

a = 1..3
array1 = [^a] | save
array2 = [^a, 5] | save
array3 = [^a, ^a] | save
array4 = [6, ^a, ^a] | save
return { array1, array2, array3, array4 }

/* RUN () RETURNS
  {array1: [[1], [2], [3]],
   array2: [[1, 5], [2, 5], [3, 5]],
   array3: [[1, 1], [2, 2], [3, 3]],
   array4: [[6, 1, 1], [6, 2, 2], [6, 3, 3]]}
---
allocated=11368/426, peak=928
*/

a = 1..3
struct1 = {a: ^a} | save
struct2 = {b: ^a, a: 7} | save
struct3 = {a: ^a, b: ^a} | save
return { struct1, struct2, struct3 }

/* RUN () RETURNS
  {struct1: [{a: 1}, {a: 2}, {a: 3}],
   struct2: [{a: 7, b: 1}, {a: 7, b: 2}, {a: 7, b: 3}],
   struct3: [{a: 1, b: 1}, {a: 2, b: 2}, {a: 3, b: 3}]}
---
allocated=8976/339, peak=1136
*/

a = [1, 2, 3]
fn1 = abs(^-^a) | save
fn2 = div(^a, 2) | save
fn3 = div(2, ^a) | save
fn4 = div(^a, ^a) | save
fn5 = replaceElement(a, ^[^a], ^2 **^ a) | save

return { fn1, fn2, fn3, fn4, fn5 }

/* RUN () RETURNS
  {fn1: [1, 2, 3],
   fn2: [0, 1, 1],
   fn3: [2, 1, 0],
   fn4: [1, 1, 1],
   fn5: [[2, 2, 3], [1, 4, 3], [1, 2, 8]]}
---
allocated=17880/676, peak=560
*/

a = [[0, 1], [2, 3], [4, 5, 6]]
pipe = (a ^| sum) | save
test1 = [1, 3, 5] ^is not Number | anyTrue
test2 = [1, 3, "5"] ^is not Number | anyTrue

return { pipe, test1, test2 }

/* RUN () RETURNS
  {pipe: [1, 5, 15],
   test1: False,
   test2: True}
---
allocated=11072/413, peak=160
$0 = *[]b0
*/

a = 1..3
r1 = 2 ..^ a | save
r2 = a ^++ 2 | save
r3 = a ^..^ (a ^+ 1) | save

return { r1, r2, r3 }

/* RUN () RETURNS
  {r1: [Range(2, 1), Range(2, 2), Range(2, 3)],
   r2: [Range(1, 2), Range(2, 3), Range(3, 4)],
   r3: [Range(1, 2), Range(2, 3), Range(3, 4)]}
---
allocated=10504/398, peak=704
*/

a = matrix([2, 3], 4..9)
b = a[2, ^1..2] | save       // [7, 8]
c = a[^1..2, ^2..3] | save   // [5, 9]

return [b, c]

/* RUN () RETURNS
  [[7, 8], [5, 9]]
---
allocated=7464/287, peak=144
*/

a = [4, 6, 5, 4]
return find(^a, a) | save

// returns the index of the first occurrence of x in array
function find(x, array) {
  trace
  for [i]: e in array sequential {
    if x == e {
      break { return i }
    }
  }
  // error if we don't find it
}

/* RUN () RETURNS
  [1, 2, 3, 1]
---
            StackBase
            distribute.r8t+126:2_3 _t0 = pipe(_t0, _t1)
            LoopCore.PipeCollectionCollector.enumerate {loop=SaverLoop(SaveElements)}
        (1) LoopCore.enumerateDefault
            LoopCore.Iterate.next {loop=SaverLoop(SaveElements), state=[ToBeSet, ToBeSet, ToBeSet, ToBeSet]}
            CollectionCore.NextTransformedIterator.at {key=[1], innerIt=ArrayIterator([4, 6, 5, 4], EnumerateAllKeys, 1), it=TransformedIterator(ToBeSet, EnumerateAllKeys, iLambda@2:7⸨a=[4, 6, 5, 4]⸩)}
            distribute.r8t+126:2_1 _a0 = find(_a1, a)
0.0s) distribute.r8t+126:6_0 trace {x=4, array=[4, 6, 5, 4]}
            ... (1) ...
            LoopCore.Iterate.next {loop=SaverLoop(SaveElements), state=[1, ToBeSet, ToBeSet, ToBeSet]}
            CollectionCore.NextTransformedIterator.at {key=[2], innerIt=ArrayIterator([4, 6, 5, 4], EnumerateAllKeys, 2), it=TransformedIterator(ToBeSet, EnumerateAllKeys, iLambda@2:7⸨a=[4, 6, 5, 4]⸩)}
            distribute.r8t+126:2_1 _a0 = find(_a1, a)
0.0s) distribute.r8t+126:6_0 trace {x=6, array=[4, 6, 5, 4]}
            ... (1) ...
            LoopCore.Iterate.next {loop=SaverLoop(SaveElements), state=[1, 2, ToBeSet, ToBeSet]}
            CollectionCore.NextTransformedIterator.at {key=[3], innerIt=ArrayIterator([4, 6, 5, 4], EnumerateAllKeys, 3), it=TransformedIterator(ToBeSet, EnumerateAllKeys, iLambda@2:7⸨a=[4, 6, 5, 4]⸩)}
            distribute.r8t+126:2_1 _a0 = find(_a1, a)
0.0s) distribute.r8t+126:6_0 trace {x=5, array=[4, 6, 5, 4]}
            ... (1) ...
            LoopCore.Iterate.next {loop=SaverLoop(SaveElements), state=[1, 2, 3, ToBeSet]}
            CollectionCore.NextTransformedIterator.at {key=[4], innerIt=ArrayIterator([4, 6, 5, 4], EnumerateAllKeys, 4), it=TransformedIterator(ToBeSet, EnumerateAllKeys, iLambda@2:7⸨a=[4, 6, 5, 4]⸩)}
            distribute.r8t+126:2_1 _a0 = find(_a1, a)
0.0s) distribute.r8t+126:6_0 trace {x=4, array=[4, 6, 5, 4]}
---
allocated=10312/379, peak=2384
*/
