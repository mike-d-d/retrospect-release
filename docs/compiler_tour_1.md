# Compiler tour, Part 1

[TOC]

## Overview

This is an introduction to the internals of the Retrospect compiler, via a
series of progressively more complex examples. For each example we show a small
Retrospect program and the VM instructions that that program is translated into,
and then provide pointers to the relevant parts of the compiler. The compiler is
structured as three separate passes, but each pass must handle all of the
language features; focusing initially on very simple programs lets us get a
sense of how each piece of the compiler works without having to deal with the
complexity required for more sophisticated language features.

While we will give brief explanations of the relevant language, VM, and compiler
concepts as we go, coverage of all three will be incomplete; for full details
see the [language reference](language_reference.md), the
[VM reference](virtual_machine.md), the
[Enumeration and Collectors API](loops.md), and the compiler source code.

## A very simple program, start to finish

Here's our starting point:

```
a = 3
b = 1 + 3 * a + a ** 2
return b
```

... and here are the virtual machine instructions the compiler produces as its
output:

```
a = 3
_t0 = multiply(3, a)
_t0 = add(1, _t0)
_t1 = exponent(a, 2)
b = add(_t0, _t1)
return b
```

First, note that this is a text representation of the VM instructions, but the
compiler actually produces its output by calling methods on the
`org.retrolang.Vm` interface; the compiler test harness
provides a mock implementation of that interface that emits this textual format,
but the "real" implementation of that interface will directly create the
internal representation of these instructions ready for execution.

Second, note that the text representation of the VM instructions looks a little
like a simplified version of the source code. This may be misleading; there are
eight VM instructions, and the three used in this example (Set, Call, and
Return) each correspond to a simple Retrospect statement, but several of the
other instructions (e.g. Branch) have no corresponding Retrospect statement, and
most Retrospect language features require multiple VM instructions to express.

Even without knowing the details of the VM, that compilation output should be
pretty easy to understand; the only differences from the source are:

*   The mathematical operators (`+`, `*`, and `**`) have been replaced with
    calls to named functions (`add`, `multiply`, and `exponent`).
*   Temporaries (`_t0` and `_t1`) have been introduced so that each function
    call is a separate instruction.

To get from the input to the output, the compiler:

1.  Creates a `Vm.ModuleBuilder` into which the code will be compiled
    *   This is the scope in which any types or functions defined by the program
        will be created.
2.  Parses the input string using the grammar in `Retrospect.g4`
    *   The parser is generated by [ANTLR](https://www.antlr.org) from that
        grammar definition.
3.  Constructs a `Symbols` instance
    *   A `Symbols` holds pieces of global state for compiling a program, the
        most interesting of which are Maps of the types and functions declared
        in the program (for this example those are both empty).
4.  Constructs a `BlockCompiler` instance for compiling the main program
    *   A `BlockCompiler` holds several pieces of state related to the
        compilation of a single code block (main program, method definition, or
        loop body), the most interesting of which is a `Scope` with entries for
        each variable name.
5.  Runs `PassOne`, which scans the program for assignment statements and adds
    scope entries for all the variables it sees (in this case, `a` and `b`).
6.  Runs `PassTwo`, which determines the set of variables read and/or written by
    each statement, identifies a number of common errors (e.g. variable set but
    never used, or used without having been set), and collects the information
    needed to construct closure objects.
7.  Runs `PassThree`, which emits the output instructions.

Step 1 is done before calling the compiler (in this case, `CompilerTest`
constructs a MockVM, but a Retrospect service would use the real VM). Steps 2
and 3 are done by `Compiler.compile`, and the remaining steps are done in the
second half of `Symbols.doCompile` (the first half of that method deals with
type, function, and method declarations, which this example does not use).

The rest of this section will provide more detail on some of those steps.

## Parsing with ANTLR

Given the grammar definition in `Retrospect.g4`, ANTLR generates 40-some Java
classes with names that end in `Context` -- e.g. `HashExpressionContext` for
instances of the `#` expression, and `AssignmentStatementContext` for assignment
statements. Given a Retrospect program as a sequence of characters, it then
constructs a tree of those objects that the rest of the compiler works from. For
example, parsing our simple program

```
a = 3
b = 1 + 3 * a + a ** 2
return b
```

produces a tree of 20 nodes that could be displayed as

```
UnitContext
. BlockContext
. . AssignmentStatementContext
. . . LowerIdContext // a
. . . AssignOpContext // =
. . . NumberExpressionContext // 3
. . AssignmentStatementContext
. . . LowerIdContext // b
. . . AssignOpContext // =
. . . OpExpressionContext // +
. . . . OpExpressionContext // +
. . . . . NumberExpressionContext // 1
. . . . . OpExpressionContext // *
. . . . . . NumberExpressionContext // 3
. . . . . . IdRefExpressionContext // a
. . . . OpExpressionContext // **
. . . . . IdRefExpressionContext // a
. . . . . NumberExpressionContext // 2
. . ReturnStatementContext
. . . IdRefExpressionContext // b
```

Beyond the standard BNF-like grammar constructions, `Retrospect.g4` uses a
couple of ANTLR-specific idioms:

*   The `separator` rule uses a Java-defined method (`Compiler.atBreak`) to
    match at end-of-line, end-of-file or before a "`}`" so that the
    statement-terminating "`;`" can be elided in those situations.

*   The `forLoop`, `breakStmt`, `lambdaArrow`, and `lowerId` rules use a
    `locals` attribute to create an additional field in those ANTLR-generated
    classes for use by the rest of the compiler. For example,
    `LowerIdContext.entry` links each `lowerId` to the corresponding scope
    entry; it is set by PassOne (for left-hand-side references) or PassTwo (for
    right-hand-side references), and read by PassThree.

## ANTLR visitor methods

ANTLR also generates a `RetrospectBaseVisitor` class, which several of the
compiler classes inherit from. This class makes it easy to write code that walks
the tree created by the parser; it defines a `visit(tree)` method that can be
called with any of the parse tree types, and dispatches to an appropriately
typed and named method. For example, `PassTwo` defines

*   `visitAssignmentStatement(AssignmentStatementContext ctx)`
*   `visitReturnStatement(ReturnStatementContext ctx)`
*   `visitNumberExpression(NumberExpressionContext ctx)`
*   `visitOpExpression(OpExpressionContext ctx)`
*   etc.

and `visitOpExpression(ctx)` calls `visit(ctx.left)` and `visit(ctx.right)` to
recursively visit the subexpressions.

## Parallel Compilation

Once a program's types and functions have been created with the ModuleBuilder,
each method definition can be compiled independently, as can the main program.
Within a method definition, each lambda expression and loop body is used to
define another method, and can be compiled indepenently of the enclosing method
once PassTwo is complete (determining the variables that the lambda or loop is
closed over). Each of these independent compilation units emits instructions to
a separate InstructionBlock, and so can be done in parallel. Symbols creates a
separate ForkJoinTask for each independent unit, adding them all as children of
a single CountedCompleter (the `baseTask`).

## Temporaries

Expression compilation often needs to use a Local (the VM equivalent of a
Retrospect variable) to store the results of an intermediate expression. The VM
allows us to create as many Locals as we need, but we try to reduce the number
of temporaries created by reusing them -- note that in the example above we used
`_t0` to first store `3 * a` and then `1 + 3 * a`. This is done with a simple
stack scheme for tracking in-use temporaries:

*   BlockCompiler maintains a list (`tmps`) of all temporaries created so far
    for this InstructionBlock (all Locals are private to a single
    InstructionBlock); when additional temporaries must be created they are
    appended to this list.

*   `nextTmp` identifies the first element of `tmps` that is not currently in
    use.

`saveTmpState` just saves the current value of `nextTmp`; a subsequent call to
`resetTmps` restores the saved value, effectively freeing any temporaries that
had been allocated in the meantime.

Temporaries are only used within a single statement, so the temporary state is
always fully reset after compiling each statement.

## ExpressionCompiler and its subclasses

Most of the interesting work in compilation is done in PassThree, and much of
the work in PassThree is done by ExpressionCompiler. An ExpressionCompiler
visits a parse tree and returns a `Vm.Expr`, which can then be used when
emitting a VM instruction. A `Vm.Expr` can be a constant or a Local, but not a
function call; when a function call is needed ExpressionCompiler allocates a
temporary and emits a function call to store the desired value into the
temporary.

ExpressionCompiler has two more specialized subclasses:

*   `Setter`, used to set a Local to the value of a given expression; and
*   `Tester`, used to conditionally branch if the value of a given expression is
    `True` or `False`.

So for example `PassThree.visitAssignmentStatement`, visiting the parsed
representation of `a = 3`, just creates an `ExpressionCompiler.Setter` for `a`
(the local on left hand side) and has it visit `3` (the expression on the right
hand side). Setter doesn't override `visitNumberExpression`, so we use the
method on ExpressionCompiler, which just converts the numeric string to a
constant `Vm.Expr`. Then `Setter.compileSet` calls `emitSet`, and we're done.

(Note that this is the simplest path through
`PassThree.visitAssignmentStatement`; there is more complex logic there to deal
with indices on the left hand side, which we will look at later.)

Visiting the next assignment statement (`b = 1 + 3 * a + a ** 2`) works the same
way, although ExpressionCompiler has more to do this time.
`ExpressionCompiler.visitOpExpression` has complexity to deal with distributed
operators and various special cases, but for these simple binary operators it
can be boiled down to:

```
int tmpState = blockCompiler.saveTmpState();
Expr left = blockCompiler.compile(ctx.left);
Expr right = blockCompiler.compile(ctx.right);
blockCompiler.resetTmps(tmpState);
Local output = outputLocal();
instructionBlock.emitCall(output, fn, left, right);
return output;
```

The `blockCompiler.compile` calls just recursively visit the left and right
subexpressions with an ExpressionCompiler. They're preceded by a call to
`saveTmpState` and followed by a call to `resetTmps` to the saved state, so that
any temporaries allocated for the results of the subexpressions will be
re-usable after this method returns. The call to `outputLocal` marks the key
difference between ExpressionCompiler and the Setter subclass; on a Setter, it
returns the Local that was passed to the constructor, while on an
ExpressionCompiler it allocates a temporary and returns that.

Note that we `resetTmps` before calling `outputLocal`, so an ExpressionCompiler
can re-use a temporary used by one of its subexpression to store the result of
the function call. That happened in the example above, when compiling `b = 1 + 3
* a + a ** 2`:

```
_t0 = multiply(3, a)
_t0 = add(1, _t0)
_t1 = exponent(a, 2)
b = add(_t0, _t1)
```

(Note that the final call to `add` stores the result in `b`, rather than a
temporary, because that was emitted by a Setter whose `outputLocal` returned `b`
(while the recursive calls for its left and right went to an ExpressionCompiler,
and so put their results in temporaries.)

--------------------------------------------------------------------------------

\> &nbsp; &nbsp; [Part 2](compiler_tour_2.md) &nbsp; &nbsp;
[Part 3](compiler_tour_3.md) &nbsp; &nbsp; [Part 4](compiler_tour_4.md)
