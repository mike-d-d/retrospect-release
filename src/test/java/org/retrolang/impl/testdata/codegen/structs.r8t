// Verify code generation for some struct edge cases

if prep {
  _ = test({x: 1, y: 0}, {x: 3, y: 2, z: 6})
  _ = test({x: 0, y: 0}, {x: 5, y: "huh", z: "wat"})
  _ = test({x: 1, y: 1}, {x: 7, y: 1, z: 8})
}
return test({x: 1, y: 1}, {x: 9, y: "wat", z: "huh"})

function test(s1, s2) = withKeys(s1) | [k, v] -> (v == 0 ? Absent : s2 @ k) | save


/* CODEGEN test RETURNS
{x: 9, y: "wat"}
---
test_0({x: i1, y: i2}, {x: i3, y: i4⸨0:i5; 1:x6:String⸩, z: i7⸨0:i8; 1:x9:String⸩}):
  1: AtomicInteger.incrementAndGet(0);
  2: I10 ← 0;
  3: I11 ← 0;
  4: I12 ← 0;
  5: I13 ← 0;
= 6: I14 ← iAdd(I10, 1);
  7: test I10 == 0; F:→ 42
  8: I15 ← I1;
= 9: X16 ← StructType.key({x,y}, I10);
 10: test I15 == 0; T:→ 46
 11: I15 ← StructType.index({x,y,z}, X16);
 12: test I15 < 0; T:→ 56
 13: test I15 == 0; T:→ 48
 14: test I15 == 1; F:→ 43
 15: I17 ← I5;
 16: X18 ← X6;
 17: I15 ← I4;
=18: test I15 == 1; F:→ 50
 19: test Objects.equals(X18, "wat") == 0; T:→ 56
=20: I15 ← 2;
=21: I16 ← StructType.index({x,y}, X16);
 22: test I16 < 0; T:→ 56
 23: test I16 == 0; T:→ 51
 24: I18 ← I12;
 25: I16 ← I11;
 26: I20 ← I17;
 27: I19 ← I15;
=28: test I19 == 0; F:→ 30
 29: test I20 == 1; F:→ 56
-30: I10 ← I14;
 31: I11 ← I16;
 32: I12 ← I18;
 33: I13 ← I19;
 34: test I10 < 2; T:→ 6
 35: dropRef{X6, X9};
 36: TState.setResultTemplates(X0, [{x: i0⸨0:i4; 1:Absent⸩, y: i8⸨0:1; 1:Absent; 2:"wat"⸩}]);
 37: X1 ← TState.fnResultBytes(X0, 12);
 38: setInt[](X1, 4, I12);
 39: setInt[](X1, 0, I11);
 40: setInt[](X1, 8, I13);
 41: return
-42: I15 ← I2; → 9
-43: I17 ← I8;
 44: X18 ← X9;
 45: I15 ← I7; → 18
-46: I17 ← 0;
 47: I15 ← 1; → 21
-48: I17 ← I3;
=49: I15 ← 0; → 21
-50: test I15 == 0; T:→ 49, F:→ 20
-51: test I15 2 (< 3); T:→ 56
 52: I20 ← 1;
 53: I19 ← I13;
 54: I18 ← I17;
 55: I16 ← I15; → 28
-56: X14 ← newStackEntry(⟦StructCore.NextStructIterator.startLoop ∥ index=I10, it=StructIterator({x: I1, y: I2}, EnumerateAllKeys, I10)⟧);
 57: X1 ← TState.fillStackEntry(X0, null, X14, ⟨⸨[x0:String, b0]; Absent⸩, StructIterator({x: b0, y: b0}, EnumerateAllKeys, b0)⟩, mMemo_1@xxxx, null);
 58: X1 ← TState.fillStackEntry(X0, X1, ⟦CollectionCore.NextWithKeysIterator.next⟧, ⟨⸨[x0:String, [x0:String, b0]]; Absent⸩, WithKeysIterator(StructIterator({x: b0, y: b0}, EnumerateAllKeys, b0)), TransformedIterator((empty), EnumerateAllKeys, lambda@8:46⸨s2={x: b0, y: ⸨b0; x0:String⸩, z: ⸨b0; x0:String⸩}⸩)⟩, mMemo_2@xxxx, null);
 59: X2 ← newStackEntry(⟦CollectionCore.NextTransformedIterator.next ∥ it=TransformedIterator((empty), EnumerateAllKeys, lambda@8:46⸨s2={x: I3, y: I4⸨0:I5; 1:X6⸩, z: I7⸨0:I8; 1:X9⸩}⸩)⟧);
 60: X1 ← TState.fillStackEntry(X0, X1, X2, ⟨⸨[x0:String, ⸨b0; Absent; "wat"⸩]; Absent⸩, TransformedIterator(WithKeysIterator(StructIterator({x: b0, y: b0}, EnumerateAllKeys, b0)), EnumerateAllKeys, lambda@8:46⸨s2={x: b0, y: ⸨b0; x0:String⸩, z: ⸨b0; x0:String⸩}⸩), SaverLoop(SaveElements), {x: ⸨b0; Absent⸩, y: ⸨1; Absent; "wat"⸩}⟩, mMemo_8@xxxx, null);
 61: X2 ← newStackEntry(⟦LoopCore.Iterate.next ∥ loop=SaverLoop(SaveElements), state={x: I11⸨0:I12; 1:Absent⸩, y: I13⸨0:1; 1:Absent; 2:"wat"⸩}⟧);
 62: X1 ← TState.fillStackEntry(X0, X1, X2, ⟨{x: ⸨b0; Absent⸩, y: ⸨1; Absent; "wat"⸩}, SaverLoop(SaveElements)⟩, mMemo_15@xxxx, null);
 63: X1 ← TState.fillStackEntry(X0, X1, ⟦LoopCore.enumerateDefault⟧, ⟨{x: ⸨b0; Absent⸩, y: ⸨1; Absent; "wat"⸩}, SaverLoop(SaveElements)⟩, mMemo_16@xxxx, null);
 64: X1 ← TState.fillStackEntry(X0, X1, ⟦LoopCore.PipeCollectionCollector.enumerate ∥ loop=SaverLoop(SaveElements)⟧, ⟨{x: ⸨b0; Absent⸩, y: ⸨1; Absent; "wat"⸩}⟩, mMemo_23@xxxx, null);
 65: X1 ← TState.fillStackEntry(X0, X1, ⟦structs.r8t+2:8_3 _t0 = pipe(_t0, _t1)⟧, ⟨{x: ⸨b0; Absent⸩, y: ⸨1; Absent; "wat"⸩}⟩, mMemo_x@xxxx, null);
 66: TState.setStackRest(X0, X1);
 67: return
---
allocated=120/5, peak=48
*/
