# Compiler tour, Part 4

[TOC]

## Parallel loops

Retrospect's language support for parallelizable loops is one of its more
distinctive features. For example, given an array (or other collection) `nums`
and a function for identifying values that are likely anomalous (`looksSketchy`)
this program will return the mean of the non-anomalous values and the array
indices (or other keys) of the anomalous values:

```
for k: v in nums {
  if looksSketchy(v) {
    anomalies << k
  } else {
    vSum << v
  }
} collect {
  vSum =| sum
  anomalies =| saveUnordered
}
return { vSum, anomalies }
```

The loop has two collected outputs: `vSum` (the sum of the non-anomalous values)
and `anomalies` (an unordered array of the indices of the anomalous values). The
collected variables are listed in the "`collect`" section at the end of the
loop, with a *collector* specified for each one. The loop body emits values to
these collected variables with the `<<` statement, and the collector determines
how the final value is computed from the emitted values.

Because the loop is not marked `sequential`, the loop body executions may happen
in parallel and/or out of order. Using collectors for the loop outputs enables
the results to be computed coherently.

The compiler emits these instructions for the main program:

```
vSum_ro = sum()
vSum_ro, _t0, _t1 = loopHelper(vSum_ro, nums, EnumerateWithKeys, True)
anomalies_ro = saveUnordered()
anomalies_ro, _t2, _t1 = loopHelper(anomalies_ro, nums, _t1, True)
_t0 = enumerate(nums, _t1, loop@1(vSum_ro, anomalies_ro), loop@1_state(vSum_rw: _t0, anomalies_rw: _t2))
vSum_rw, anomalies_rw = unloop@1_state(_t0)
vSum = finalResultHelper(vSum_ro, vSum_rw)
anomalies = finalResultHelper(anomalies_ro, anomalies_rw)
return {anomalies: anomalies, vSum: vSum}
```

In addition to the temporaries, the generated code for loops includes some
additional locals associated with collected variables, with suffixes "`_ro`" and
"`_rw`":

*   "`_ro`" locals (such as `vSum_ro` above) store fixed (read-only) information
    associated with the collector â€” most often just the collector itself.
*   "`_rw`" locals store the current (read/write) state of a collected variable;
    for example, `vSum_rw` will store the sum of the non-anomalous values seen
    so far.

The actual loop execution is done by the call to `enumerate`, which takes the
same arguments as `iterate` (collection, enumeration kind, loop closure, initial
state) and has the same return value (final state), but requires that the loop
closure implement some additional methods (besides `nextState`) to support
parallel execution.

For this example the second (eKind) argument to `enumerate` will be
`EnumerateWithKeys`, which will cause `nextState` to be called with (key, value)
pairs (recall that the previous example passed `EnumerateValues`, and so was
only called with values).

(Those instructions do not just pass `EnumerateWithKeys` directly; they are a
little more complex, because each of the collectors is given the opportunity to
upgrade the eKind to `EnumerateAllKeys`, but neither of these (`sum` and
`saveUnordered`) needs anything other than values.)

In addition to `enumerate`, the instructions above use some other library
functions:

*   `loopHelper(collector, collection, maxEKind=, isParallel)` returns the `_ro`
    value for the given collector, the initial `_rw` value, and the "enumeration
    kind" that the collector requires.
*   `finalResultHelper(ro, rw)` determines the collected variable's final value,
    given the final state.

(See the [Enumeration and Collectors API](loops.md) for the full details of
eKinds and these helpers.)

Note that the loop closure passed to `enumerate` contains `vSum_ro` and
`anomalies_ro`, and the initial state contains the initial `vSum_rw` and
`anomalies_rw`.

After the loop completes, the remaining instructions extract the final `vSum_rw`
and `anomalies_rw` from the final state, derive the resulting values of `vSum`
and `anomalies`, and return them as a struct.

All of this code is generated by `PassThree.visitForStatement`, using some of
the functionality that was skipped for the simpler example in the previous part
of this tour.

## The loop body

As in the previous, sequential loop example the compiler defines a loop closure
type, a loop state type, and a `nextState` method:

```
private compound loop@1{vSum_ro,anomalies_ro} is Loop
private compound loop@1_state{vSum_rw,anomalies_rw}

method nextState(_loop, _state, _element) _0 is loop@1 {
    vSum_ro, anomalies_ro = unloop@1(_loop)
    vSum_rw, anomalies_rw = unloop@1_state(_state)
    _key, _element = unarray2(_element)
    branch L1 if _element is Absent
    k = _key
    v = _element
    _t0 = looksSketchy(v)
    branch L2 if not _t0
    anomalies_rw = emitValue(anomalies_ro, anomalies_rw, k)
    branch L3
  L2:
    vSum_rw = emitValue(vSum_ro, vSum_rw, v)
  L3:
  L1:
    vSum_rw = emitKey(vSum_ro, vSum_rw, _key)
    anomalies_rw = emitKey(anomalies_ro, anomalies_rw, _key)
    return loop@1_state(vSum_rw, anomalies_rw)
}
```

The `unarray2` call extracts the two elements of the (key, value) array that is
passed as the second argument to `nextState`.

The `branch L1 if _element is Absent` test will never be true for this program,
since eKind will always be `EnumerateWithKeys` (`nextState` is only called with
Absent elements if eKind is `EnumerateAllKeys`).

The `<<` statements are compiled to calls of the `emitValue` function; for the
`sum` collector this will add the input to the current state, while for the
`saveUnordered` collector it appends the value to an array of results.

After execution of the loop body each of the collectors is given the opportunity
to do something with the key, but neither of these two collectors does.

Finally a new state (containing the updated values of `vSum_rw` and
`anomalies_rw`) is returned.

There is some complexity here to support the full range of possibilities for
collectors (the compiler does not have any knowledge of specific collectors, so
generates this fully-general code for each of them), but it allows the language
to support very flexible parallel computation with minimal effort on the
programmer's part.

## Supporting parallel execution

Providing an initial state and a `nextState` method is enough for sequential
execution, but to support parallel execution the loop value passed to
`enumerate` must support three additional methods:

*   `emptyState(loop)` returns an initial state that can be used to process some
    of the collection elements independently of the original execution thread;
*   `splitState(loop, state=)` is another option for starting a separate
    execution thread; and
*   `combineStates(loop, state1, state2)` merges the results of two execution
    threads.

(See the [Enumeration and Collectors API](loops.md) for the details of how these
are used.)

The compiler emits methods for each of these functions, just delegating to the
corresponding collector methods. Here is the `emptyState` method it emits:

```
method emptyState(loop) _0 is loop@1 {
    vSum_ro, anomalies_ro = unloop@1(loop)
    vSum_rw = emptyStateHelper(vSum_ro)
    anomalies_rw = emptyStateHelper(anomalies_ro)
    return loop@1_state(vSum_rw, anomalies_rw)
}
```

It extracts `vSum_ro` and `anomalies_ro` from the loop closure, calls
`emptyStateHelper` on each of them (which just calls the `emptyState` method
implemented by the collector), and assembles the results into a new loop state
value.

The `splitState` method is similar, but this time it has both a loop closure and
a state to unpack. After splitting each of the collector states, it assembles
them into two complete loop states and returns them (one as the function result,
and one as the new value of the inout `state` argument):

```
method splitState(loop, state) _0 is loop@1 {
    vSum_ro, anomalies_ro = unloop@1(loop)
    vSum_rw1, anomalies_rw1 = unloop@1_state(state)
    vSum_rw2, vSum_rw1 = splitStateHelper(vSum_ro, vSum_rw1)
    anomalies_rw2, anomalies_rw1 = splitStateHelper(anomalies_ro, anomalies_rw1)
    return loop@1_state(vSum_rw: vSum_rw2, anomalies_rw: anomalies_rw2),
           loop@1_state(vSum_rw: vSum_rw1, anomalies_rw: anomalies_rw1)
}
```

And `combineStates` is similarly predictable; this time we have two state values
to unpack, and the combined states from each of the collectors are assembled
into a combined loop state:

```
method combineStates(loop, state1, state2) _0 is loop@1 {
    vSum_ro, anomalies_ro = unloop@1(loop)
    vSum_rw1, anomalies_rw1 = unloop@1_state(state1)
    vSum_rw2, anomalies_rw2 = unloop@1_state(state2)
    vSum_rw1 = combineStatesHelper(vSum_ro, vSum_rw1, vSum_rw2)
    anomalies_rw1 = combineStatesHelper(anomalies_ro, anomalies_rw1, anomalies_rw2)
    return loop@1_state(vSum_rw: vSum_rw1, anomalies_rw: anomalies_rw1)
}
```

These three methods are emitted by `defineEmptyStateMethod`,
`defineSplitStateMethod`, and `defineCombineStatesMethod`, all of which are
called at the end of `Loop.compileBody`.

--------------------------------------------------------------------------------

[Part 1](compiler_tour_1.md) &nbsp; &nbsp; [Part 2](compiler_tour_2.md) &nbsp;
&nbsp; [Part 3](compiler_tour_3.md) &nbsp; &nbsp; <
