return recursiveFib(prep ? 6 : 8)

function recursiveFib(n) {
  if (n < 2) {
    return 1
  } else {
    r1 = recursiveFib(n - 1)
    r2 = recursiveFib(n - 2)
    if n > 3 {
      trace n
    }
    return r1 + r2
  }
}

/* CODEGEN recursiveFib RETURNS
34
---
recursiveFib_0(i1):
  1: AtomicInteger.incrementAndGet(0);
  2: X2 ← null;
  3: test I1 < 2; T:→ 26
  4: I3 ← Math.subtractExact(I1, 1); ArithmeticException:→ 37
  5: [i0] ← recursiveFib_0(X0, I3); X3 ← stackRest; unwind:→ 35
  6: I4 ← int[](TState.fnResultBytes(X0, 0), 0);
  7: TState.clearResultTemplates(X0);
  8: test X3 == null; T:→ 11
  9: X2 ← newStackEntry(trace.r8t+0:7_5 r1 = recursiveFib(_t0) {n=I1});
 10: X2 ← TState.fillStackEntry(X0, X3, X2, b0, mMemo_x@xxxx, null);
-11: I3 ← Math.subtractExact(I1, 2); ArithmeticException:→ 33
 12: [i0] ← recursiveFib_0(X0, I3); X3 ← stackRest; unwind:→ 31
 13: I5 ← int[](TState.fnResultBytes(X0, 0), 0);
 14: TState.clearResultTemplates(X0);
 15: test X3 == null; T:→ 18
 16: X6 ← newStackEntry(trace.r8t+0:8_7 r2 = recursiveFib(_t0) {n=I1, r1=I4});
 17: X2 ← TState.fillStackEntry(X0, X3, X6, b0, mMemo_x@xxxx, X2);
-18: test 3 < I1; F:→ 21
 19: X3 ← newStackEntry(trace.r8t+0:10_10 trace n {n=I1, r1=I4, r2=I5});
 20: X2 ← TState.trace(X0, trace n, X3, X2);
-21: I1 ← Math.addExact(I4, I5); ArithmeticException:→ 27
=22: TState.setResultTemplates(X0, [i0]);
 23: setInt[](TState.fnResultBytes(X0, 4), 0, I1);
 24: TState.setStackRest(X0, X2);
 25: return
-26: I1 ← 1; → 22
-27: X1 ← newStackEntry(trace.r8t+0:12_12 _t0 = add(r1, r2) {r1=I4, r2=I5});
 28: X2 ← TState.fillStackEntry(X0, null, X1, b0, mMemo_x@xxxx, X2);
=29: TState.setStackRest(X0, X2);
 30: return
-31: X5 ← newStackEntry(trace.r8t+0:8_7 r2 = recursiveFib(_t0) {n=I1, r1=I4});
 32: X2 ← TState.fillStackEntry(X0, X3, X5, b0, mMemo_x@xxxx, X2); → 29
-33: X3 ← newStackEntry(trace.r8t+0:8_6 _t0 = subtract(n, 2) {n=I1, r1=I4});
 34: X2 ← TState.fillStackEntry(X0, null, X3, b0, mMemo_x@xxxx, X2); → 29
-35: X2 ← newStackEntry(trace.r8t+0:7_5 r1 = recursiveFib(_t0) {n=I1});
 36: X2 ← TState.fillStackEntry(X0, X3, X2, b0, mMemo_x@xxxx, null); → 29
-37: X2 ← newStackEntry(trace.r8t+0:4_0 _t0 = lessThan(n, 2) {n=I1});
 38: X2 ← TState.fillStackEntry(X0, null, X2, b0, mMemo_x@xxxx, null); → 29
---
            StackBase
        (4) trace.r8t+0:1_6 _t0 = recursiveFib(_t0)
        (3) trace.r8t+0:7_5 r1 = recursiveFib(_t0) {n=8}
        (2) trace.r8t+0:7_5 r1 = recursiveFib(_t0) {n=7}
        (1) trace.r8t+0:7_5 r1 = recursiveFib(_t0) {n=6}
            trace.r8t+0:7_5 r1 = recursiveFib(_t0) {n=5}
0.0s) trace.r8t+0:10_10 trace n {n=4, r1=3, r2=2}
            ... (1) ...
0.0s) trace.r8t+0:10_10 trace n {n=5, r1=5, r2=3}
            ... (2) ...
            trace.r8t+0:8_7 r2 = recursiveFib(_t0) {n=6, r1=8}
0.0s) trace.r8t+0:10_10 trace n {n=4, r1=3, r2=2}
            ... (2) ...
0.0s) trace.r8t+0:10_10 trace n {n=6, r1=8, r2=5}
            ... (3) ...
        (5) trace.r8t+0:8_7 r2 = recursiveFib(_t0) {n=7, r1=13}
            trace.r8t+0:7_5 r1 = recursiveFib(_t0) {n=5}
0.0s) trace.r8t+0:10_10 trace n {n=4, r1=3, r2=2}
            ... (5) ...
0.0s) trace.r8t+0:10_10 trace n {n=5, r1=5, r2=3}
            ... (3) ...
0.0s) trace.r8t+0:10_10 trace n {n=7, r1=13, r2=8}
            ... (4) ...
        (7) trace.r8t+0:8_7 r2 = recursiveFib(_t0) {n=8, r1=21}
        (6) trace.r8t+0:7_5 r1 = recursiveFib(_t0) {n=6}
            trace.r8t+0:7_5 r1 = recursiveFib(_t0) {n=5}
0.0s) trace.r8t+0:10_10 trace n {n=4, r1=3, r2=2}
            ... (6) ...
0.0s) trace.r8t+0:10_10 trace n {n=5, r1=5, r2=3}
            ... (7) ...
            trace.r8t+0:8_7 r2 = recursiveFib(_t0) {n=6, r1=8}
0.0s) trace.r8t+0:10_10 trace n {n=4, r1=3, r2=2}
            ... (7) ...
0.0s) trace.r8t+0:10_10 trace n {n=6, r1=8, r2=5}
            ... (4) ...
0.0s) trace.r8t+0:10_10 trace n {n=8, r1=21, r2=13}
---
allocated=1976/51, peak=1904
*/
