// Create, walk, and drop a lot of binary trees, based on
// https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/binarytrees.html

minDepth = 4
maxDepth = max(minDepth + 2, n)
stretchDepth = maxDepth + 1
stretchCheck = check(createTree(stretchDepth))

longLivedTree = createTree(maxDepth)
depth = minDepth
for sequential depth {
  if depth > maxDepth { break }
  iterations = number(bitShift(u32(1), maxDepth - depth + minDepth))
  check = 1..iterations | -> check(createTree(depth)) | sum
  results << { iterations, depth, check }
  depth += 2
} collect {
  results =| saveSequential
}
longLivedCheck = check(longLivedTree)
return { stretchDepth, stretchCheck, results, longLivedCheck }

//

compound TreeNode

function createTree(depth) =
    (depth == 0) ? TreeNode_([None, None])
                 : TreeNode_([createTree(depth - 1), createTree(depth - 1)])

function check(TreeNode tree) {
  [left, right] = tree_
  return left is None ? 1 : check(left) + check(right) + 1
}

/* RUN (n=10) RETURNS
  {longLivedCheck: 2047,
   results:
      [{check: 31744, depth: 4, iterations: 1024},
       {check: 32512, depth: 6, iterations: 256},
       {check: 32704, depth: 8, iterations: 64},
       {check: 32752, depth: 10, iterations: 16}],
   stretchCheck: 4095,
   stretchDepth: 11}
---
allocated=76606376/3004379, peak=131120
$0 = *[b0⸨0:None; 1:TreeNode(x0:$0)⸩, b1⸨0:None; 1:TreeNode(x1:$0)⸩]
$1 = *[]{check: i0, depth: b1, iterations: i2}
*/
