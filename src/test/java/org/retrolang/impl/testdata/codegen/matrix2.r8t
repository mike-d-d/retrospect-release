if prep {
  _ = test([1, 2, 3])
  _ = test([2, 0, 4])
}
return [test([4, 5, 6]), test([3, 4, 0])]

function test(dims) {
  zero = newMatrix(sizes(dims), 0)
  keys = matrix(dims) | -> # - 1
  return keys | sum(zero)
}

/* CODEGEN test RETURNS
[[180, 240, 300], [0, 0, 0]]
---
test_0([i1, i2, i3]):
  1: AtomicInteger.incrementAndGet(0);
  2: test I1 < 0; T:→ 68
  3: test I2 < 0; T:→ 68
  4: test I3 < 0; T:→ 68
  5: test I1 == 0; T:→ 32
  6: test I2 == 0; T:→ 32
  7: test I3 == 0; T:→ 32
  8: I7 ← 0;
  9: I8 ← 0;
 10: I9 ← 0;
 11: I4 ← 1;
 12: I5 ← 1;
 13: I6 ← 0;
=14: I6 ← iAdd(I6, 1);
=15: I10 ← 0;
=16: I11 ← iAdd(I10, 1);
 17: test I10 == 0; F:→ 45
 18: I12 ← I4;
=19: I12 ← Math.subtractExact(I12, 1); ArithmeticException:→ 54
 20: I13 ← iSub(I11, 1);
 21: test I13 == 0; F:→ 48
 22: I14 ← I7;
=23: I12 ← Math.addExact(I14, I12); ArithmeticException:→ 54
 24: test I13 == 0; F:→ 51
 25: I7 ← I12;
=26: I10 ← I11;
 27: test I10 < 3; T:→ 16
 28: test I6 < I3; T:→ 14
 29: test I5 < I2; F:→ 41
 30: I5 ← iAdd(I5, 1);
 31: I6 ← 1; → 15
-32: I7 ← 0;
 33: I8 ← 0;
 34: I9 ← 0;
=35: TState.setResultTemplates(X0, [[i0, i4, i8]]);
 36: X1 ← TState.fnResultBytes(X0, 12);
 37: setInt[](X1, 0, I7);
 38: setInt[](X1, 4, I8);
 39: setInt[](X1, 8, I9);
 40: return
-41: test I4 < I1; F:→ 35
 42: I4 ← iAdd(I4, 1);
 43: I5 ← 1;
 44: I6 ← 1; → 15
-45: test I10 == 1; F:→ 47
 46: I12 ← I5; → 19
-47: I12 ← I6; → 19
-48: test I13 == 1; F:→ 50
 49: I14 ← I8; → 23
-50: I14 ← I9; → 23
-51: test I13 == 1; F:→ 53
 52: I8 ← I12; → 26
-53: I9 ← I12; → 26
-54: X11 ← newStackEntry(ArrayCore.NextArrayIterator.startLoop {index=I10, it=ArrayIterator([I4, I5, I6], EnumerateAllKeys, I10)});
 55: X10 ← TState.fillStackEntry(X0, null, X11, [⸨[[b0], b0]; Absent⸩, ArrayIterator([b0, b0, b0], EnumerateAllKeys, b0), TransformedIterator((empty), EnumerateAllKeys, `subtract:2:#.`(1))], mMemo_1@xxxx, null);
 56: X10 ← TState.fillStackEntry(X0, X10, CollectionCore.NextTransformedIterator.next {it=TransformedIterator(ToBeSet, EnumerateAllKeys, `subtract:2:#.`(1))}, [⸨[[b0], b0]; Absent⸩, TransformedIterator(ArrayIterator([b0, b0, b0], EnumerateAllKeys, b0), EnumerateAllKeys, `subtract:2:#.`(1)), BinaryUpdateWithCollection(`add:2`), [b0, b0, i0]], mMemo_4@xxxx, null);
 57: X11 ← newStackEntry(LoopCore.Iterate.next {loop=BinaryUpdateWithCollection(`add:2`), state=[I7, I8, I9]});
 58: X7 ← TState.fillStackEntry(X0, X10, X11, [[b0, b0, i0], Sum([0, 0, 0]), TransformedIterator(BaseIterator(EnumerateValues, [b0, b0, b0], [b0, b0, b0]), EnumerateValues, lambda@9:24)], mMemo_13@xxxx, null);
 59: X7 ← TState.fillStackEntry(X0, X7, MatrixCore.BinaryUpdateMatrix.afterSizesRhs, [[b0, b0, i0], Sum([0, 0, 0]), TransformedIterator(BaseIterator(EnumerateValues, [b0, b0, b0], [b0, b0, b0]), EnumerateValues, lambda@9:24)], mMemo_17@xxxx, null);
 60: X7 ← TState.fillStackEntry(X0, X7, ReducerCore.nextStateSum, [[b0, b0, i0], Sum([0, 0, 0]), TransformedIterator(BaseIterator(EnumerateValues, [b0, b0, b0], [b0, b0, b0]), EnumerateValues, lambda@9:24)], mMemo_18@xxxx, null);
 61: X8 ← newStackEntry(LoopCore.Iterate.nextState {loop=Sum([0, 0, 0]), it=TransformedIterator(BaseIterator(EnumerateValues, [I4, I5, I6], [I1, I2, I3]), EnumerateValues, lambda@9:24)});
 62: X1 ← TState.fillStackEntry(X0, X7, X8, [[b0, b0, i0], Sum([0, 0, 0])], mMemo_28@xxxx, null);
 63: X1 ← TState.fillStackEntry(X0, X1, LoopCore.enumerateDefault, [[b0, b0, i0], Sum([0, 0, 0])], mMemo_29@xxxx, null);
 64: X1 ← TState.fillStackEntry(X0, X1, LoopCore.PipeCollectionCollector.enumerate {loop=Sum([0, 0, 0])}, [b0, b0, i0], mMemo_33@xxxx, null);
 65: X1 ← TState.fillStackEntry(X0, X1, matrix2.r8t+0:10_5 _t0 = pipe(keys, _t0), [b0, b0, i0], mMemo_x@xxxx, null);
=66: TState.setStackRest(X0, X1);
 67: return
-68: X4 ← newStackEntry(matrix2.r8t+0:8_0 _t0 = sizes(dims) {dims=[I1, I2, I3]});
 69: X1 ← TState.fillStackEntry(X0, null, X4, [b0, b0, i0], mMemo_x@xxxx, null); → 66
---
allocated=288/11, peak=184
*/
