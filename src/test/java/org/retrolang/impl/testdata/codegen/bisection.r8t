// Find roots by bisection.
// This version uses a sequential loop.

fn = fn(True)
root1 = findRoot(fn, 0.5, 2.5, 1e-6)
root2 = findRoot(fn, -2.5, -0.5, 1e-6)
outOfBounds = findRoot(fn, 2, 3, 1e-6)
discontinuousFn = fn(False)
discontinuous = findRoot(discontinuousFn, 0, 2, 1e-6)
return {discontinuous, outOfBounds, root1, root2}

// Returns an x in [xMin, xMax], or None
function findRoot(f, xMin, xMax, eps) {
  fxMin = f[xMin]
  fxMax = f[xMax]
  if abs(fxMin) <= eps {
    return xMin
  } else if abs(fxMax) <= eps {
    return xMax
  } else if fxMin < 0 and fxMax > 0 {
    x0 = xMin; x1 = xMax
  } else if fxMin > 0 and fxMax < 0 {
    x0 = xMax; x1 = xMin
  } else {
    return None
  }
  // Loop invariant: f[x0] < -eps, f[x1] > eps
  for sequential x0, x1 {
    xm = (x0 + x1) / 2
    if xm == x0 or xm == x1 {
      break { return None }
    }
    fxm = f[xm]
    if abs(fxm) <= eps {
      break { return xm }
    } else if (fxm < 0) {
      x0 = xm
    } else {
      x1 = xm
    }
  }
}

// A workaround for not yet having code generation for multi-method dispatch
function fn(continuous) = [x] -> fn(continuous, x)

function fn(continuous, x) = continuous ? x * x - 2 : (x > 1 ? 1 : -1)

/* CODEGEN findRoot RETURNS
  {discontinuous: None,
   outOfBounds: None,
   root1: 1.4142136573791504,
   root2: -1.4142136573791504}
---
findRoot_0(lambda@42:30⸨continuous=i1⸨0:False; 1:True⸩⸩, d2, d3, 1.0E-6):
  1: AtomicInteger.incrementAndGet(0);
  2: test I1 0 (< 2); F:→ 14
  3: test 1 < D2; T:→ 20
  4: test 1 < D4; F:→ 20
= 5: D6 ← D2;
  6: D2 ← D4;
= 7: D4 ← dDiv(dAdd(D6, D2), 2);
  8: test Double.isNaN(D4) == 0; F:→ 41
  9: test D4 == D6; T:→ 38
 10: test D4 == D2; T:→ 41
 11: test I1 0 (< 2); F:→ 27
 12: test 1 < D4; T:→ 30
=13: D6 ← D4; → 7
-14: D6 ← dSub(dMul(D2, D2), 2);
 15: test 1.0E-6 < Math.abs(D6); F:→ 20
 16: D8 ← dSub(dMul(D4, D4), 2);
 17: test 1.0E-6 < Math.abs(D8); F:→ 20
 18: test D6 < 0; F:→ 24
 19: test 0 < D8; T:→ 5
=20: X6 ← newStackEntry(bisection.r8t+3:11_0 fxMin = at(f, [xMin]) {f=lambda@42:30⸨continuous=I1⸨0:False; 1:True⸩⸩, xMin=D2, xMax=D4, eps=1.0E-6});
 21: X1 ← TState.fillStackEntry(X0, null, X6, ⸨d0; None⸩, mMemo_x@xxxx, null);
=22: TState.setStackRest(X0, X1);
 23: return
-24: test 0 < D6; F:→ 20
 25: test D8 < 0; F:→ 31
 26: D6 ← D4; → 7
-27: D8 ← dSub(dMul(D4, D4), 2);
 28: test 1.0E-6 < Math.abs(D8); F:→ 40
 29: test D8 < 0; T:→ 13
-30: D2 ← D4; → 7
-31: D4 ← 0;
 32: I1 ← 1;
=33: TState.setResultTemplates(X0, [i0⸨0:d8; 1:None⸩]);
 34: X0 ← TState.fnResultBytes(X0, 16);
 35: setDouble[](X0, 8, D4);
 36: setInt[](X0, 0, I1);
 37: return
-38: D4 ← 0;
 39: I1 ← 1; → 33
-40: I1 ← 0; → 33
-41: X4 ← newStackEntry(LoopCore.IterateUnbounded.afterAt {state=loop@25_state⸨x0=D6, x1=D2⸩, lambda=loop@25⸨f=lambda@42:30⸨continuous=I1⸨0:False; 1:True⸩⸩, eps=1.0E-6⸩});
 42: X1 ← TState.fillStackEntry(X0, null, X4, LoopExit(⸨loop@25_break@28; loop@25_break@32⸨xm=d0⸩⸩), mMemo_20@xxxx, null);
 43: X1 ← TState.fillStackEntry(X0, X1, bisection.r8t+3:25_30 _t0 = iterateUnbounded(loop@25⸨f=f, eps=eps⸩, loop@25_state⸨x0=x0, x1=x1⸩), ⸨d0; None⸩, mMemo_x@xxxx, null); → 22
---
allocated=544/20, peak=152
*/
