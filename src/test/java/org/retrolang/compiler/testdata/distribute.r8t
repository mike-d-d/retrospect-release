// Test compilation of expressions with distributed operators and functions

a = [1, 2, 3]
left = a ^+ 4
right = 4 /^ a
both = a ^*^ a

return [left, right, both]

/* COMPILE ():
---
    a = [1, 2, 3]  // 1:0
    _t0 = curryLambda('add:2', [0, -1], [4])  // 2:0
    left = pipe(a, _t0)
    _t0 = curryLambda('divide:2', [-1, 0], [4])  // 3:0
    right = pipe(a, _t0)
    _t0 = join(a, a)  // 4:0
    both = pipe(_t0, 'multiply:2')
    return [left, right, both]  // 6:0
*/

a = [1, 2, 3]
lt = a ^< 2
le = a ^<= 2
le2 = 2 <=^ a
ne = a ^!=^ (-^a)

return [lt, le, le2, ne]

/* COMPILE ():
---
    a = [1, 2, 3]  // 1:0
    _t0 = curryLambda('lessThan:2', [0, -1], [2])  // 2:0
    lt = pipe(a, _t0)
    _t0 = curryLambda('lessThan:2', [-1, 0], [2])  // 3:0
    le = pipe(a, _t0)
    le = pipe(le, 'not:1')
    _t0 = curryLambda('lessThan:2', [0, -1], [2])  // 4:0
    le2 = pipe(a, _t0)
    le2 = pipe(le2, 'not:1')
    _t0 = pipe(a, 'negative:1')  // 5:0
    _t0 = join(a, _t0)
    ne = pipe(_t0, 'equal:2')
    ne = pipe(ne, 'not:1')
    return [lt, le, le2, ne]  // 7:0
*/

a = [1, 2, 3]
array1 = [^a]
array2 = [^a, 5]
array3 = [^a, ^a]
array4 = [6, ^a, ^a]
return [array1, array2, array3, array4]

/* COMPILE ():
---
    a = [1, 2, 3]  // 1:0
    array1 = pipe(a, lambda_toArray1)  // 2:0
    _t0 = curryLambda(lambda_toArray2, [0, -1], [5])  // 3:0
    array2 = pipe(a, _t0)
    array3 = join(a, a)  // 4:0
    _t0 = join(a, a)  // 5:0
    _t1 = curryLambda(lambda_toArray3, [-1, 1, 2], [6])
    array4 = pipe(_t0, _t1)
    return [array1, array2, array3, array4]  // 6:0
*/

a = [1, 2, 3]
struct1 = {a: ^a}
struct2 = {b: ^a, a: 7}
struct3 = {a: ^a, b: ^a}
return [struct1, struct2, struct3]

/* COMPILE ():
---
    a = [1, 2, 3]  // 1:0
    struct1 = pipe(a, lambda_struct{a})  // 2:0
    _t0 = curryLambda(lambda_struct{a,b}, [-1, 0], [7])  // 3:0
    struct2 = pipe(a, _t0)
    _t0 = join(a, a)  // 4:0
    struct3 = pipe(_t0, lambda_struct{a,b})
    return [struct1, struct2, struct3]  // 5:0
*/

a = [1, 2, 3]
fn1 = abs(^-^a)
fn2 = div(^a, 2)
fn3 = div(2, ^a)
fn4 = div(^a, ^a)
fn5 = replaceElement(a, ^a, ^2 **^ a)

return [fn1, fn2, fn3, fn4, fn5]

/* COMPILE ():
---
    a = [1, 2, 3]  // 1:0
    _t0 = pipe(a, 'negative:1')  // 2:0
    fn1 = pipe(_t0, 'abs:1')
    _t0 = curryLambda('div:2', [0, -1], [2])  // 3:0
    fn2 = pipe(a, _t0)
    _t0 = curryLambda('div:2', [-1, 0], [2])  // 4:0
    fn3 = pipe(a, _t0)
    _t0 = join(a, a)  // 5:0
    fn4 = pipe(_t0, 'div:2')
    _t0 = curryLambda('exponent:2', [-1, 0], [2])  // 6:0
    _t0 = pipe(a, _t0)
    _t0 = join(a, _t0)
    _t1 = curryLambda('replaceElement:3', [-1, 1, 2], [a])
    fn5 = pipe(_t0, _t1)
    return [fn1, fn2, fn3, fn4, fn5]  // 8:0
*/

a = [1, 2, 3]
pipe = ([^a] ^| save) | save
test = a ^is not Number | anyTrue

return [pipe, test]

/* COMPILE ():
---
    a = [1, 2, 3]  // 1:0
    _t0 = pipe(a, lambda_toArray1)  // 2:0
    _t1 = save()
    _t2 = curryLambda('pipe:2', [0, -1], [_t1])
    _t0 = pipe(_t0, _t2)
    _t1 = save()
    pipe = pipe(_t0, _t1)
    _t0 = pipe(a, lambda_isNumber)  // 3:0
    _t0 = pipe(_t0, 'not:1')
    _t1 = anyTrue()
    test = pipe(_t0, _t1)
    return [pipe, test]  // 5:0
*/

a = [1, 2, 3]
r1 = 2 ..^ a
r2 = a ^++ 2
r3 = a ^..^ (a ^+ 1)

return [r1, r2, r3]

/* COMPILE ():
---
    a = [1, 2, 3]  // 1:0
    _t0 = curryLambda('range:2', [-1, 0], [2])  // 2:0
    r1 = pipe(a, _t0)
    _t0 = curryLambda('rangeWithSize:2', [0, -1], [2])  // 3:0
    r2 = pipe(a, _t0)
    _t0 = curryLambda('add:2', [0, -1], [1])  // 4:0
    _t0 = pipe(a, _t0)
    _t0 = join(a, _t0)
    r3 = pipe(_t0, 'range:2')
    return [r1, r2, r3]  // 6:0
*/

a = [3, 2, 1]
b = ["abc", "def", "ghi"]
c = b[^a]                    // ["ghi", "def", "abc"]
d = b^[3]                    // ["c", "f", "i"]
e = b^[^a]                   // ["c", "e", "g"]

return [c, d, e]

/* COMPILE ():
---
    a = [3, 2, 1]  // 1:0
    b = ["abc", "def", "ghi"]  // 2:0
    _t0 = pipe(a, lambda_toArray1)  // 3:0
    _t1 = curryLambda('at:2', [-1, 0], [b])
    c = pipe(_t0, _t1)
    _t0 = curryLambda('at:2', [0, -1], [[3]])  // 4:0
    d = pipe(b, _t0)
    _t0 = pipe(a, lambda_toArray1)  // 5:0
    _t0 = join(b, _t0)
    e = pipe(_t0, 'at:2')
    return [c, d, e]  // 7:0
*/

a = matrix([2, 3], 4..9)
b = a[2, ^1..2]       // [7, 8]
c = a[^1..2, ^2..3]   // [5, 9]

return [b, c]

/* COMPILE ():
---
    _t0 = range(4, 9)  // 1:0
    a = matrix([2, 3], _t0)
    _t0 = range(1, 2)  // 2:0
    _t1 = curryLambda(lambda_toArray2, [-1, 0], [2])
    _t0 = pipe(_t0, _t1)
    _t1 = curryLambda('at:2', [-1, 0], [a])
    b = pipe(_t0, _t1)
    _t0 = range(1, 2)  // 3:0
    _t1 = range(2, 3)
    _t0 = join(_t0, _t1)
    _t1 = curryLambda('at:2', [-1, 0], [a])
    c = pipe(_t0, _t1)
    return [b, c]  // 5:0
*/

a = [[3], [2], [1]]
b = ["abc", "def", "ghi"]
c = b@^a                    // ["ghi", "def", "abc"]
d = b^@[3]                  // ["c", "f", "i"]
e = b^@^a                   // ["c", "e", "g"]

return [c, d, e]

/* COMPILE ():
---
    a = [[3], [2], [1]]  // 1:0
    b = ["abc", "def", "ghi"]  // 2:0
    _t0 = curryLambda('at:2', [-1, 0], [b])  // 3:0
    c = pipe(a, _t0)
    _t0 = curryLambda('at:2', [0, -1], [[3]])  // 4:0
    d = pipe(b, _t0)
    _t0 = join(b, a)  // 5:0
    e = pipe(_t0, 'at:2')
    return [c, d, e]  // 7:0
*/
